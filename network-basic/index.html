<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>计算机网络 | Memorykk&#39;s blog</title>
<link rel="shortcut icon" href="https://memorykki.github.io/favicon.ico">
<link href="https://memorykki.github.io/styles/main.css" rel="stylesheet">
<link href="//at.alicdn.com/t/font_1678829_ntebi130zaa.css" rel="stylesheet">
<link rel="alternate" type="application/rss+xml" title="Memorykk&#39;s blog » Feed" href="https://memorykki.github.io/atom.xml">


  <script async src="https://www.googletagmanager.com/gtag/js?id=G-61KQ1XYC4T"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-61KQ1XYC4T');
  </script>



  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b89f2652bbc909bb41e06c21123d1797";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <meta name="description" content="概述、物理层、数据链路层、网络层、运输层、应用层。
70页、5万字，超长总结。


目录


1. 概述

1.1. 互联网概述
1.2. 互联网的组成

1.2.1. 边缘部分

1.2.1.1. 客户-服务器方式
1.2.1.2. 对等..." />
  <meta name="keywords" content="Network" />

  <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/2.3.1/css/bootstrap.css" rel="stylesheet">
  <link href="https://memorykki.github.io/media/css/jquery.tocify.css" rel="stylesheet">

  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
  <script src="https://memorykki.github.io/media/scripts/jquery.ui.core.js"></script>
  <script src="https://memorykki.github.io/media/scripts/bootstrap.js"></script>
  <script src="https://memorykki.github.io/media/scripts/jquery.tocify.js"></script>

  <style>
    #toc .nav-list > .active > a{
      border: 1px solid #000;
      border-radius: 10px;
      background-color: unset;
    }
    #toc a {
      color: #000000;
    }
    #toc {
      border: 0;
    }
  </style>
</head>

<body style="height: auto">
  <div id="toc" style="right: 20px; top: 80px"></div>
  <div class="main animated">
    <div class="header animated fadeInDown">
  <div class="site_title_container">
    <div class="site_title">
      <a href="https://memorykki.github.io">
        Memorykk&#39;s blog
      </a>
    </div>
  </div>
  <div class="my_socials">
    
      <a href="mailto:memorykki@gmail.com">
        <i class="iconfont"><svg t="1672505472759" class="icon" viewBox="-400 -400 1600 1600" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="656" width="25" height="25"><path d="M741.12 305.737143H276.114286L511.817143 528.457143z" fill="#606060" p-id="657"></path><path d="M524.8 566.857143a18.651429 18.651429 0 0 1-25.417143 0.182857l-62.72-59.245714L256 668.525714v49.737143h512v-49.737143l-181.577143-161.645714L524.8 566.857143zM256 337.005714v282.514286l153.965714-136.96zM768 619.52V330.788571l-155.245714 150.491429z" fill="#606060" p-id="658"></path><path d="M512 9.142857C234.24 9.142857 9.142857 234.24 9.142857 512S234.24 1014.857143 512 1014.857143 1014.857143 789.76 1014.857143 512 789.76 9.142857 512 9.142857z m292.571429 727.405714c0 10.057143-8.228571 18.285714-18.285715 18.285715H237.714286c-10.057143 0-18.285714-8.228571-18.285715-18.285715V287.451429c0-10.057143 8.228571-18.285714 18.285715-18.285715h548.571428c10.057143 0 18.285714 8.228571 18.285715 18.285715v449.097142z" fill="#606060" p-id="659"></path></svg></i>
      </a>
    

    
      
        <a href="https://github.com/memorykki" target="_blank">
          <i class="iconfont icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
    <a href="https://memorykki.github.io/atom.xml" target="_blank">
      <i class="iconfont icon-rss"></i>
    </a>
  </div>
</div>

<div class="header_menu">
  
  
  <a href="/" class="menu">Index</a>
  

  
  <a href="/archives" class="menu">Archives</a>
  

  
  <a href="/tags" class="menu">Tags</a>
  

  
  <a href="/about" class="menu">About</a>
  

  <div class="gridea-search-div">
    <form id="gridea-search-form" action="https://memorykki.github.io/search/">
      <input class="gridea-search-input" autocomplete="off" spellcheck="false" name="q" />
    </form>
  </div>
</div>

    <div class="autopagerize_page_element">
      <div class="content">
        <div class="post_page">
          <div class="post animated fadeInDown">
            <div class="post_title post_detail_title">
              <h1 class="indicator-free">
                <a>
                  计算机网络</a>
              </h2>
              <span class="article-info">2021-03-14, 44811 words, 160 min read</span>
            </div>
            <div class="post_content markdown">
              <p class="md_block">
                <span class="md_line md_line_start md_line_end">
                  <p>概述、物理层、数据链路层、网络层、运输层、应用层。</p>
<p>70页、5万字，超长总结。</p>
<!-- more -->
<hr>
<p><strong>目录</strong></p>
<!-- TOC -->
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a>
<ul>
<li><a href="#1-1-%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">1.1. 互联网概述</a></li>
<li><a href="#1-2-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">1.2. 互联网的组成</a>
<ul>
<li><a href="#1-2-1-%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86">1.2.1. 边缘部分</a>
<ul>
<li><a href="#1-2-1-1-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F">1.2.1.1. 客户-服务器方式</a></li>
<li><a href="#1-2-1-2-%E5%AF%B9%E7%AD%89%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">1.2.1.2. 对等连接方式</a></li>
</ul>
</li>
<li><a href="#1-2-2-%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86">1.2.2. 核心部分</a>
<ul>
<li><a href="#1-2-2-1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">1.2.2.1. 电路交换</a></li>
<li><a href="#1-2-2-2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">1.2.2.2. 分组交换</a></li>
<li><a href="#1-2-2-3-%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2">1.2.2.3. 报文交换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">1.3. 计算机网络的性能指标</a>
<ul>
<li><a href="#1-3-1-%E9%80%9F%E7%8E%87">1.3.1. 速率</a></li>
<li><a href="#1-3-2-%E5%B8%A6%E5%AE%BD">1.3.2. 带宽</a></li>
<li><a href="#1-3-3-%E5%90%9E%E5%90%90%E9%87%8F">1.3.3. 吞吐量</a></li>
<li><a href="#1-3-4-%E6%97%B6%E5%BB%B6">1.3.4. 时延</a></li>
<li><a href="#1-3-5-%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">1.3.5. 时延带宽积</a></li>
<li><a href="#1-3-6-%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4RTT">1.3.6. 往返时间RTT</a></li>
<li><a href="#1-3-7-%E5%88%A9%E7%94%A8%E7%8E%87">1.3.7. 利用率</a></li>
</ul>
</li>
<li><a href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">1.4. 计算机网络体系结构</a>
<ul>
<li><a href="#1-4-1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">1.4.1. OSI七层模型</a>
<ul>
<li><a href="#1-4-1-1-%E7%89%A9%E7%90%86%E5%B1%82">1.4.1.1. 物理层</a></li>
<li><a href="#1-4-1-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">1.4.1.2. 数据链路层</a></li>
<li><a href="#1-4-1-3-%E7%BD%91%E7%BB%9C%E5%B1%82">1.4.1.3. 网络层</a></li>
<li><a href="#1-4-1-4-%E4%BC%A0%E8%BE%93%E5%B1%82">1.4.1.4. 传输层</a></li>
<li><a href="#1-4-1-5-%E4%BC%9A%E8%AF%9D%E5%B1%82">1.4.1.5. 会话层</a></li>
<li><a href="#1-4-1-6-%E8%A1%A8%E7%A4%BA%E5%B1%82">1.4.1.6. 表示层</a></li>
<li><a href="#1-4-1-7-%E5%BA%94%E7%94%A8%E5%B1%82">1.4.1.7. 应用层</a></li>
</ul>
</li>
<li><a href="#1-4-2-%E6%80%BB%E7%BB%93">1.4.2. 总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E7%89%A9%E7%90%86%E5%B1%82">2. 物理层</a>
<ul>
<li><a href="#2-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1">2.1. 数据通信</a>
<ul>
<li><a href="#2-1-1-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F">2.1.1. 数据通信系统</a></li>
<li><a href="#2-1-2-%E4%BF%A1%E9%81%93">2.1.2. 信道</a></li>
<li><a href="#2-1-3-%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">2.1.3. 信道的极限容量</a></li>
</ul>
</li>
<li><a href="#2-2-%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">2.2. 物理层下的传输媒体</a></li>
<li><a href="#2-3-%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">2.3. 信道复用技术</a></li>
<li><a href="#2-4-%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">2.4. 宽带接入技术</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3. 数据链路层</a>
<ul>
<li><a href="#3-1-%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">3.1. 使用点对点信道</a>
<ul>
<li><a href="#3-1-1-%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">3.1.1. 三个基本问题</a>
<ul>
<li><a href="#3-1-1-1-%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">3.1.1.1. 封装成帧</a></li>
<li><a href="#3-1-1-2-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">3.1.1.2. 透明传输</a></li>
<li><a href="#3-1-1-3-%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">3.1.1.3. 差错检测</a></li>
</ul>
</li>
<li><a href="#3-1-2-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP">3.1.2. 点对点协议PPP</a>
<ul>
<li><a href="#3-1-2-1-%E5%8D%8F%E8%AE%AE%E7%BB%84%E6%88%90">3.1.2.1. 协议组成</a></li>
<li><a href="#3-1-2-2-PPP%E5%B8%A7%E6%A0%BC%E5%BC%8F">3.1.2.2. PPP帧格式</a></li>
<li><a href="#3-1-2-3-PPP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">3.1.2.3. PPP协议工作状态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">3.2. 使用广播信道</a>
<ul>
<li><a href="#3-2-1-%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">3.2.1. 局域网的数据链路层</a>
<ul>
<li><a href="#3-2-1-1-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%87%E5%87%86">3.2.1.1. 以太网的两个标准</a></li>
<li><a href="#3-2-1-2-%E9%80%82%E9%85%8D%E5%99%A8">3.2.1.2. 适配器</a></li>
</ul>
</li>
<li><a href="#3-2-2-CSMACD%E5%8D%8F%E8%AE%AE">3.2.2. CSMA/CD协议</a></li>
<li><a href="#3-2-3-%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91">3.2.3. 使用集线器的星形拓扑</a></li>
<li><a href="#3-2-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">3.2.4. 信道利用率</a></li>
<li><a href="#3-2-5-MAC%E5%B1%82">3.2.5. MAC层</a>
<ul>
<li><a href="#3-2-5-1-MAC%E5%9C%B0%E5%9D%80">3.2.5.1. MAC地址</a></li>
<li><a href="#3-2-5-2-MAC%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F">3.2.5.2. MAC帧的格式</a></li>
</ul>
</li>
<li><a href="#3-2-6-%E6%89%A9%E5%B1%95%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">3.2.6. 扩展的以太网</a>
<ul>
<li><a href="#3-2-6-1-%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.1. 物理层扩展</a></li>
<li><a href="#3-2-6-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95">3.2.6.2. 数据链路层扩展</a>
<ul>
<li><a href="#3-2-6-2-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%89%B9%E7%82%B9">3.2.6.2.1. 交换机特点</a></li>
<li><a href="#3-2-6-2-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">3.2.6.2.2. 路由器与交换机的主要区别</a></li>
<li><a href="#3-2-6-2-3-%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD">3.2.6.2.3. 以太网的自学习功能</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E7%BD%91%E7%BB%9C%E5%B1%82">4. 网络层</a>
<ul>
<li><a href="#4-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1">4.1. 网络层提供的两种服务</a></li>
<li><a href="#4-2-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP">4.2. 网际协议IP</a>
<ul>
<li><a href="#4-2-1-%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80">4.2.1. 分类的IP地址</a>
<ul>
<li><a href="#4-2-1-1-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%A1%A8%E7%A4%BA">4.2.1.1. IP地址的表示</a></li>
<li><a href="#4-2-1-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80">4.2.1.2. 常见的三类IP地址</a></li>
</ul>
</li>
<li><a href="#4-2-2-%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80">4.2.2. 私有地址</a></li>
<li><a href="#4-2-3-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT">4.2.3. 网络地址转换NAT</a></li>
<li><a href="#4-2-4-DHCP%E5%8D%8F%E8%AE%AE">4.2.4. DHCP协议</a></li>
<li><a href="#4-2-5-IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80">4.2.5. IP地址与硬件地址</a></li>
<li><a href="#4-2-6-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP">4.2.6. 地址解析协议ARP</a>
<ul>
<li><a href="#4-2-6-1-%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.1. 同一局域网</a></li>
<li><a href="#4-2-6-2-%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91">4.2.6.2. 不在同一局域网</a></li>
</ul>
</li>
<li><a href="#4-2-7-%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AERARP">4.2.7. 逆地址解析协议RARP</a></li>
<li><a href="#4-2-8-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F">4.2.8. IP数据报的格式</a></li>
<li><a href="#4-2-9-IP%E5%B1%82%E8%BD%AC%E5%8F%91%E5%88%86%E7%BB%84%E7%9A%84%E6%B5%81%E7%A8%8B">4.2.9. IP层转发分组的流程</a></li>
</ul>
</li>
<li><a href="#4-3-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3. 划分子网和构造超网</a>
<ul>
<li><a href="#4-3-1-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">4.3.1. 划分子网</a>
<ul>
<li><a href="#4-3-1-1-%E4%B8%89%E7%BA%A7IP%E5%9C%B0%E5%9D%80">4.3.1.1. 三级IP地址</a></li>
<li><a href="#4-3-1-2-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81">4.3.1.2. 子网掩码</a></li>
<li><a href="#4-3-1-3-%E4%BD%BF%E7%94%A8%E5%AD%90%E7%BD%91%E7%9A%84%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91">4.3.1.3. 使用子网的分组转发</a></li>
</ul>
</li>
<li><a href="#4-3-2-%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91">4.3.2. 构造超网</a>
<ul>
<li><a href="#4-3-2-1-%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BC%80">4.3.2.1. 网络前缀</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-4-ICMP%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE">4.4. ICMP网际控制报文协议</a></li>
<li><a href="#4-5-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">4.5. 路由选择协议</a>
<ul>
<li><a href="#4-5-1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AERIP">4.5.1. 内部网关协议RIP</a>
<ul>
<li><a href="#4-5-1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">4.5.1.1. 工作原理</a></li>
<li><a href="#4-5-1-2-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95">4.5.1.2. 距离向量算法</a></li>
</ul>
</li>
<li><a href="#4-5-2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEOSPF">4.5.2. 内部网关协议OSPF</a></li>
<li><a href="#4-5-3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEBGP">4.5.3. 外部网关协议BGP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E8%BF%90%E8%BE%93%E5%B1%82">5. 运输层</a>
<ul>
<li><a href="#5-1-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0">5.1. 协议概述</a>
<ul>
<li><a href="#5-1-1-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">5.1.1. 进程之间的通信</a></li>
<li><a href="#5-1-2-%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE">5.1.2. 两个主要协议</a></li>
<li><a href="#5-1-3-%E7%AB%AF%E5%8F%A3">5.1.3. 端口</a></li>
</ul>
</li>
<li><a href="#5-2-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP">5.2. 用户数据报协议UDP</a></li>
<li><a href="#5-3-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E6%A6%82%E8%BF%B0">5.3. 传输控制协议TCP概述</a>
<ul>
<li><a href="#5-3-1-TCP%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9">5.3.1. TCP的主要特点</a></li>
<li><a href="#5-3-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5">5.3.2. TCP的连接</a></li>
</ul>
</li>
<li><a href="#5-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">5.4. 可靠传输的工作原理</a>
<ul>
<li><a href="#5-4-1-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE">5.4.1. 停止等待协议</a>
<ul>
<li><a href="#5-4-1-1-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5">5.4.1.1. 无差错情况</a></li>
<li><a href="#5-4-1-2-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99">5.4.1.2. 出现差错</a></li>
<li><a href="#5-4-1-3-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0">5.4.1.3. 确认丢失和确认迟到</a></li>
<li><a href="#5-4-1-4-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">5.4.1.4. 信道利用率</a></li>
</ul>
</li>
<li><a href="#5-4-2-%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE">5.4.2. 连续ARQ协议</a></li>
</ul>
</li>
<li><a href="#5-5-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F">5.5. TCP报文段格式</a></li>
<li><a href="#5-6-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0">5.6. TCP可靠传输的实现</a>
<ul>
<li><a href="#5-6-1-%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">5.6.1. 以字节为单位的滑动窗口</a></li>
<li><a href="#5-6-2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9">5.6.2. 超时重传时间的选择</a></li>
<li><a href="#5-6-3-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4SACK">5.6.3. 选择确认SACK</a></li>
</ul>
</li>
<li><a href="#5-7-TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7. TCP的流量控制</a>
<ul>
<li><a href="#5-7-1-%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">5.7.1. 利用滑动窗口实现流量控制</a></li>
<li><a href="#5-7-2-TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87">5.7.2. TCP的传输效率</a></li>
</ul>
</li>
<li><a href="#5-8-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">5.8. TCP的拥塞控制</a>
<ul>
<li><a href="#5-8-1-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86">5.8.1. 拥塞控制的一般原理</a></li>
<li><a href="#5-8-2-TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">5.8.2. TCP的拥塞控制方法</a>
<ul>
<li><a href="#5-8-2-1-%E6%85%A2%E5%BC%80%E5%A7%8B">5.8.2.1. 慢开始</a></li>
<li><a href="#5-8-2-2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">5.8.2.2. 拥塞避免</a></li>
<li><a href="#5-8-2-3-%E5%BF%AB%E9%87%8D%E4%BC%A0">5.8.2.3. 快重传</a></li>
<li><a href="#5-8-2-4-%E5%BF%AB%E6%81%A2%E5%A4%8D">5.8.2.4. 快恢复</a></li>
<li><a href="#5-8-2-5-%E6%80%BB%E7%BB%93">5.8.2.5. 总结</a></li>
</ul>
</li>
<li><a href="#5-8-3-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86AQM">5.8.3. 主动队列管理AQM</a></li>
</ul>
</li>
<li><a href="#5-9-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">5.9. TCP的连接管理</a>
<ul>
<li><a href="#5-9-1-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">5.9.1. TCP的连接建立</a></li>
<li><a href="#5-9-2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE">5.9.2. TCP的连接释放</a></li>
<li><a href="#5-9-3-TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">5.9.3. TCP的有限状态机</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-%E5%BA%94%E7%94%A8%E5%B1%82">6. 应用层</a>
<ul>
<li><a href="#6-1-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS">6.1. 域名系统DNS</a></li>
<li><a href="#6-2-%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">6.2. 文件传送协议</a>
<ul>
<li><a href="#6-2-1-FTP">6.2.1. FTP</a></li>
<li><a href="#6-2-2-TFTP">6.2.2. TFTP</a></li>
</ul>
</li>
<li><a href="#6-3-%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AEHTTP">6.3. 超文本传送协议HTTP</a>
<ul>
<li><a href="#6-3-1-HTTP%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B">6.3.1. HTTP基本过程</a></li>
<li><a href="#6-3-2-HTTP%E6%8A%A5%E6%96%87">6.3.2. HTTP报文</a>
<ul>
<li><a href="#6-3-2-1-HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">6.3.2.1. HTTP请求报文</a></li>
<li><a href="#6-3-2-2-HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%8A%A5%E6%96%87">6.3.2.2. HTTP响应报文报文</a></li>
</ul>
</li>
<li><a href="#6-3-3-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.3. HTTP协议的区别</a></li>
<li><a href="#6-3-4-HTTPS">6.3.4. HTTPS</a>
<ul>
<li><a href="#6-3-4-1-HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">6.3.4.1. HTTPS的工作原理</a></li>
<li><a href="#6-3-4-2-HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.4.2. HTTPS和HTTP的区别</a></li>
</ul>
</li>
<li><a href="#6-3-5-HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">6.3.5. HTTP缓存机制</a>
<ul>
<li><a href="#6-3-5-1-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98">6.3.5.1. 强制缓存</a></li>
<li><a href="#6-3-5-2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">6.3.5.2. 协商缓存</a></li>
<li><a href="#6-3-5-3-%E6%80%BB%E7%BB%93">6.3.5.3. 总结</a></li>
</ul>
</li>
<li><a href="#6-3-6-SESSION%E5%92%8CCOOKIE">6.3.6. SESSION和COOKIE</a></li>
</ul>
</li>
<li><a href="#6-4-%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">6.4. 输入URL之后会发生什么</a>
<ul>
<li><a href="#6-4-1-%E5%A4%A7%E7%BA%B2">6.4.1. 大纲</a></li>
<li><a href="#6-4-2-%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">6.4.2. 具体过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">7. 参考链接</a></li>
</ul>
<!-- /TOC -->
<hr>
<h1 id="1-概述">1. 概述</h1>
<h2 id="11-互联网概述">1.1. 互联网概述</h2>
<ul>
<li>三大网：电信网、有线电视网、计算机网络。</li>
<li>计算机网络：简称为“网络”，由若干结点和连接这些节点的链路组成。</li>
<li>互连网（internet）：网络通过路由器互连起来构成更大的计算机网络，即“网络的网络”。</li>
<li>主机：与网络相连的计算机。</li>
<li>互联网（Internet）：当前全球最大的、开放的、众多网络互连而成的特定互连网，采用TCP/IP协议族作为通信规则。</li>
<li>互联网服务提供者ISP：商业公司ISP共同拥有整个互联网。</li>
<li>互联网的多层次ISP结构：主干ISP、地区ISP、本地ISP。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://memorykki.github.io/post-images/network-basic/multi-isp.png" alt="" loading="lazy"></figure>
<ul>
<li>互联网交换点IXP：允许两个网络直接相连并交换分组，而不再需要通过更高层的ISP转发分组，从而加快效率。IXP常采用工作在数据链路层的网络交换机，用局域网连接起来。</li>
</ul>
<h2 id="12-互联网的组成">1.2. 互联网的组成</h2>
<p>从工作方式上看，分为：</p>
<ul>
<li>边缘部分：由所有来凝结在互联网上的主机组成，用户直接使用，用来进行通信和资源共享，即资源子网。</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换，即通信子网。</li>
</ul>
<h3 id="121-边缘部分">1.2.1. 边缘部分</h3>
<p>连接在互联网上的所有主机又称为“端系统”。端系统之间的通信实质是进程之间的通信。<br>
通信方式有两类：客户服务器方式（C/S）、对等方式（P2P）。</p>
<h4 id="1211-客户-服务器方式">1.2.1.1. 客户-服务器方式</h4>
<p>描述的是两个应用进程之间服务与被服务的关系。<br>
客户是服务请求方，服务器是服务提供方。</p>
<figure data-type="image" tabindex="2"><img src="https://memorykki.github.io/post-images/network-basic/cs.png" alt="" loading="lazy"></figure>
<p><strong>客户程序</strong></p>
<ul>
<li>被用户调用后运行，通信时主动想S发起请求，C必须知道S的地址；</li>
<li>不需要特殊的硬件和复杂的OS。</li>
</ul>
<p><strong>服务器程序</strong></p>
<ul>
<li>系统启动后自动调用并不断运行，被动地等待并接受C请求，可同时处理多个请求；</li>
<li>一般需要强大的硬件和复杂的OS支持。</li>
</ul>
<h4 id="1212-对等连接方式">1.2.1.2. 对等连接方式</h4>
<p>两台主机在通信时不区分哪个是C或S，运行P2P软件即可平等通信，本质上看认识C/S方式。</p>
<figure data-type="image" tabindex="3"><img src="https://memorykki.github.io/post-images/network-basic/p2p.png" alt="" loading="lazy"></figure>
<h3 id="122-核心部分">1.2.2. 核心部分</h3>
<p>起特殊作用的是<strong>路由器</strong>，实现分组交换。<br>
三种交换方式：电路交换、报文交换、分组交换。</p>
<h4 id="1221-电路交换">1.2.2.1. 电路交换</h4>
<p>从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源。</p>
<p>在通话之前，必须先拨号请求建立连接，也就是一条专用的物理通路。挂机后，交换机释放刚才使用的这条专用的物理通路。这种必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”的交换方式即“电路交换”。</p>
<p>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。</p>
<figure data-type="image" tabindex="4"><img src="https://memorykki.github.io/post-images/network-basic/circuitSwitch.png" alt="" loading="lazy"></figure>
<p>使用电路交换的线路的传输效率十分低。</p>
<h4 id="1222-分组交换">1.2.2.2. 分组交换</h4>
<p>采用存储转发技术，待发送的在整个数据块称为报文，发送之前将报文划分成等长的数据段，再加上必要的控制信息组成的首部构成分组，又称为“包”。</p>
<figure data-type="image" tabindex="5"><img src="https://memorykki.github.io/post-images/network-basic/message.png" alt="" loading="lazy"></figure>
<p>主机H1向主机H5发送数据。主机H1先将分组逐个地发往与它直接相连的路由器A。此时，除链路H1-A外，其他通信链路并不被目前通信的双方所占用。需要注意的是，即使是链路H1-A，也只是当分组正在此链路上传送时才被占用。在各分组传送之间的空闲时间，链路H1-A仍可为其他主机发送的分组使用。</p>
<figure data-type="image" tabindex="6"><img src="https://memorykki.github.io/post-images/network-basic/packetSwitch.png" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>优点</th>
<th>所采用的手段</th>
</tr>
</thead>
<tbody>
<tr>
<td>高效</td>
<td>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</td>
</tr>
<tr>
<td>灵活</td>
<td>为每一个分组独立地选择最合适的转发路由</td>
</tr>
<tr>
<td>迅速</td>
<td>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</td>
</tr>
<tr>
<td>可靠</td>
<td>保证可靠性的网络协议:分布式多路由的分组交换网，使网络有很好的生存性</td>
</tr>
</tbody>
</table>
<p>问题：</p>
<ul>
<li>分组在各路由器存储转发时需要排队，造成时延；</li>
<li>各分组携带的控制信息造成开销</li>
</ul>
<h4 id="1223-报文交换">1.2.2.3. 报文交换</h4>
<p>采用存储转发原理，但每次交换整个报文。</p>
<p>三种交换方式的比较：</p>
<figure data-type="image" tabindex="7"><img src="https://memorykki.github.io/post-images/network-basic/switch.png" alt="" loading="lazy"></figure>
<h2 id="13-计算机网络的性能指标">1.3. 计算机网络的性能指标</h2>
<h3 id="131-速率">1.3.1. 速率</h3>
<p>用的信息量的单位。网络技术中的速率指的是数据的传送速率，它也称为数据率或比特率( bit rate)。速率是计算机网络中最重要的一个性能指标。速率的单位是bit/s。</p>
<p>当提到网络的速率时，往往指的是额定速率或标称速率，而并非网络实际上运行的</p>
<h3 id="132-带宽">1.3.2. 带宽</h3>
<p>带宽本来是指某个信号具有的频带宽度。在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”，单位bit/s。</p>
<p>前者为频域称谓，而后者为时域称谓，其本质是相同的。</p>
<h3 id="133-吞吐量">1.3.3. 吞吐量</h3>
<p>吞吐量表示在单位时间内通过某个网络(或信道、接口)的实际的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。显然，吞吐量受网络的带宽或网络的额定速率的限制。</p>
<h3 id="134-时延">1.3.4. 时延</h3>
<p>时延包括以下几个部分：</p>
<ul>
<li>发送时延：主机或路由器发送数据帧所需要的时间</li>
</ul>
<pre><code>发送时延=数据帧长度bit/发送速率bit/s
</code></pre>
<ul>
<li>传播时延 电磁波在信道中传播一定的距离需要花费的时间。</li>
</ul>
<pre><code>传播时延=信道长度m/电磁波在信道上的传播速率m/s
</code></pre>
<p>发送时延与传输信道的长度没有关系，传播时延与信号的发送速率无关。</p>
<ul>
<li>
<p>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分<br>
组的首部、从分组中提取数据部分、进行差错检验或査找适当的路由等。</p>
</li>
<li>
<p>排队时延 分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后<br>
要先在输入队列中排队等待处理。排队时延的长短往往取决于网络当时的通信量。</p>
</li>
</ul>
<pre><code>总时延=发送时延+传播时延+处理时延+排队时延
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://memorykki.github.io/post-images/network-basic/delay.png" alt="" loading="lazy"></figure>
<p>对于高速链路，提高的仅仅是数据的发送速率而非比特在链路上的传播速率，减小了数据的发送时延，所以比特不会传送得更快。</p>
<h3 id="135-时延带宽积">1.3.5. 时延带宽积</h3>
<pre><code>时延带宽积=传播时延*带宽
</code></pre>
<p>管道中的比特数表示发送端发出的但未到达接收端的比特。</p>
<h3 id="136-往返时间rtt">1.3.6. 往返时间RTT</h3>
<p>信息双向交互一次所需的时间。</p>
<pre><code>有效数据率=数据长度/发送时间+RTT
</code></pre>
<h3 id="137-利用率">1.3.7. 利用率</h3>
<pre><code>当前时延=网络空闲时的时延/1-利用率
</code></pre>
<p>这里U是网络的利用率，数值在0到1之间。当网络的利用率达到其容量的1/2时<br>
时延就要加倍。</p>
<p>当网络的利用率接近最大值1时，网络的时延就趋于无穷大。因此我们必须有这样的概念:信道或网络的利用率过高会产生非常大的时延。</p>
<figure data-type="image" tabindex="9"><img src="https://memorykki.github.io/post-images/network-basic/delay-U.png" alt="" loading="lazy"></figure>
<h2 id="14-计算机网络体系结构">1.4. 计算机网络体系结构</h2>
<p>法律上的国际标准：OSI<br>
事实上的国籍标准：TCP/IP</p>
<p>网络协议：未进行网络中的数据交换而建立的规则、标准或约定。包括：</p>
<ul>
<li>语法：即数据与控制信息的结构或格式</li>
<li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应，例如重传或丢弃的时间</li>
<li>同步：即事件实现顺序的详细说明</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://memorykki.github.io/post-images/network-basic/OSI.png" alt="" loading="lazy"></figure>
<h3 id="141-osi七层模型">1.4.1. OSI七层模型</h3>
<p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>下4层完成通信子网的功能，上3层完成资源子网的功能。</p>
<figure data-type="image" tabindex="11"><img src="https://memorykki.github.io/post-images/network-basic/osi7.png" alt="" loading="lazy"></figure>
<h4 id="1411-物理层">1.4.1.1. 物理层</h4>
<p>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p>
<p>考虑多大的电压代表“1”“0”，接收方应如何识别，电缆的插头应有多少根引脚、如何连接等。</p>
<h4 id="1412-数据链路层">1.4.1.2. 数据链路层</h4>
<p>在物理层提供的比特流的基础上，通过差错控制、封装成帧、流量控制提供可靠的通过物理介质传输数据的方法。</p>
<p>该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。</p>
<p>数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p>
<h4 id="1413-网络层">1.4.1.3. 网络层</h4>
<p>将上层的报文段或用户数据报封装成分组，也叫IP数据报。</p>
<p>另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</p>
<p>数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。</p>
<ul>
<li>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</li>
<li>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</li>
<li>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</li>
<li>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。</li>
</ul>
<h4 id="1414-传输层">1.4.1.4. 传输层</h4>
<p>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。</p>
<ul>
<li>传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。</li>
<li>处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。</li>
</ul>
<h4 id="1415-会话层">1.4.1.5. 会话层</h4>
<p>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。</p>
<ul>
<li>会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。</li>
<li>会话流量控制：提供会话流量控制和交叉会话功能。</li>
<li>寻址：使用远程地址建立会话连接。l</li>
<li>出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用RPC均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。</li>
</ul>
<h4 id="1416-表示层">1.4.1.6. 表示层</h4>
<p>对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。</p>
<p>其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。</p>
<ul>
<li>数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。</li>
<li>数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。</li>
<li>压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。</li>
<li>数据的加密和解密：可以提高网络的安全性。</li>
</ul>
<h4 id="1417-应用层">1.4.1.7. 应用层</h4>
<p>计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，通过应用进程间的交互完成特定的网络应用。</p>
<ul>
<li>用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。</li>
<li>实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。</li>
</ul>
<h3 id="142-总结">1.4.2. 总结</h3>
<p>OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>
TCP/IP四层：网络接口层、 网际层、运输层、 应用层。<br>
五层协议：物理层、数据链路层、网络层、运输层、 应用层。</p>
<p><strong>协议</strong><br>
物理层：RJ45、CLOCK、IEEE802.3（网卡，网线，集线器，中继器，调制解调器）<br>
数据链路：PPP、FR、HDLC、VLAN、MAC（网桥，交换机）<br>
网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器、网关）<br>
传输层：TCP、UDP、SPX<br>
会话层：NFS、SQL、NETBIOS、RPC<br>
表示层：JPEG、MPEG、ASII<br>
应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p>
<figure data-type="image" tabindex="12"><img src="https://memorykki.github.io/post-images/network-basic/protocolFamily.png" alt="" loading="lazy"></figure>
<p><strong>作用</strong><br>
物理层：通过媒介传输比特，确定机械及电气规范（比特Bit）<br>
数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>
网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>
传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>
会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>
表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>
应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<figure data-type="image" tabindex="13"><img src="https://memorykki.github.io/post-images/network-basic/data.png" alt="" loading="lazy"></figure>
<p>协议数据单元PDU：对等层次之间传送的数据单位。<br>
服务数据单元SDU：层间交换的数据单位。<br>
服务访问点SAP：同意系统中相邻两层的实体交换信息的地方。</p>
<figure data-type="image" tabindex="14"><img src="https://memorykki.github.io/post-images/network-basic/service-relation.png" alt="" loading="lazy"></figure>
<p>协议是水平的，服务是垂直的。</p>
<p><strong>交换机、路由器、网关</strong></p>
<ul>
<li>
<p>交换机<br>
在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。<br>
交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。<br>
交换机被广泛应用于二层网络交换，俗称“二层交换机”。<br>
交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p>
</li>
<li>
<p>路由器<br>
路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。<br>
路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p>
</li>
<li>
<p>网关<br>
网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。<br>
在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。<br>
在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。<br>
网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。<br>
对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>
</li>
</ul>
<h1 id="2-物理层">2. 物理层</h1>
<p>首先要强调指岀，物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有许多不同方式。物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异。</p>
<p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即</p>
<ol>
<li>机械特性指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。平时常见的各种规格的接插件都有严格的标准化的规定。</li>
<li>电气特性指明在接口电缆的各条线上出现的电压的范围。</li>
<li>功能特性指明某条线上出现的某一电平的电压的意义。</li>
<li>过程特性指明对于不同功能的各种可能事件的出现顺序</li>
</ol>
<p>物理层还要完成串行-&gt;并行传输的转换。</p>
<h2 id="21-数据通信">2.1. 数据通信</h2>
<h3 id="211-数据通信系统">2.1.1. 数据通信系统</h3>
<p>可划分为三大部分，即源系统(或发送端、发送方)、传输系统(或传输网络)和目的系统(或接收端、接收方)。</p>
<figure data-type="image" tabindex="15"><img src="https://memorykki.github.io/post-images/network-basic/DataCommunication.png" alt="" loading="lazy"></figure>
<ul>
<li>模拟信号，或连续信号：代表消息的参数的取值是连续的。</li>
<li>数字信号，或离散信号：代表消息的参数的取值是离散的。代表不同离散数值的基本波形就称为码元。</li>
</ul>
<h3 id="212-信道">2.1.2. 信道</h3>
<p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p>
<ul>
<li>单向通信：称为单工通信，即只能有一个方向的通信而没有反方向的交互。无<br>
线电广播或有线电广播以及电视广播就属于这种类型</li>
<li>双向交替通信：又称为半双工通信，即通信的双方都可以发送信息，但不能双方<br>
同时发送(当然也就不能同时接收)。</li>
<li>双向同时通信：又称为全双工通信，即通信的双方可以同时发送和接收信息<br>
单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道(每个<br>
方向各一条)。</li>
</ul>
<p>显然，双向同时通信的传输效率最高。</p>
<p>来自信源的基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。所以必须对基带信号进行调制，分为两大类：</p>
<ul>
<li>基带调制：对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号，也称为编码。
<ul>
<li>不归零制</li>
<li>归零制</li>
<li>曼彻斯特编码</li>
<li>差分曼彻斯特编码</li>
</ul>
</li>
<li>带通调制：使用载波把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，经过载波调制后的信号称为带通信号，即仅在一段频率范围内能够通过信道。
<ul>
<li>调幅（AM）</li>
<li>调频（FM）</li>
<li>调相（PM）</li>
</ul>
</li>
</ul>
<h3 id="213-信道的极限容量">2.1.3. 信道的极限容量</h3>
<p>码间串扰：接收端收到的信号波形就失去了码元之间的清晰界限。<br>
严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。</p>
<p>奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题。</p>
<p>信噪比：所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为S/N，并用分贝(dB)作为度量单位。</p>
<figure data-type="image" tabindex="16"><img src="https://memorykki.github.io/post-images/network-basic/SNR.png" alt="" loading="lazy"></figure>
<p>香农公式：信道的极限信息传输速率C是</p>
<figure data-type="image" tabindex="17"><img src="https://memorykki.github.io/post-images/network-basic/shannon.png" alt="" loading="lazy"></figure>
<p>式中，W为信道的带宽(Hz);S为信道内所传信号的平均功率;N为信道内<br>
部的高斯噪声功率。</p>
<p>香农公式的意义在于:只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</p>
<p>从以上所讲的不难看出，对于频带宽度已确定的信道，可以用编码的方法让每一个码元携带更多比特的信息量。</p>
<h2 id="22-物理层下的传输媒体">2.2. 物理层下的传输媒体</h2>
<ul>
<li>导引型
<ul>
<li>双绞线</li>
<li>同轴线缆</li>
<li>光缆</li>
</ul>
</li>
<li>非导引型
<ul>
<li>短波通信</li>
<li>无线电微波通信</li>
<li>卫星通信</li>
</ul>
</li>
</ul>
<h2 id="23-信道复用技术">2.3. 信道复用技术</h2>
<figure data-type="image" tabindex="18"><img src="https://memorykki.github.io/post-images/network-basic/multiplexing.png" alt="" loading="lazy"></figure>
<ul>
<li>频分复用（FDM）：所有用户在同样的时间占用不同的带宽资源。</li>
<li>时分复用（TDM）：所有用户在不同的时间占用同样的频带宽度，又称为同步时分复用。</li>
</ul>
<figure data-type="image" tabindex="19"><img src="https://memorykki.github.io/post-images/network-basic/FDM-TDM.png" alt="" loading="lazy"></figure>
<ul>
<li>统计时分复用（STDM）：改进的时分复用，缓存用户数据放入STDM帧，又称为异步时分复用</li>
<li>波分复用（WDM）：光的频分复用。</li>
<li>码分复用（CDM）：共享信道。</li>
</ul>
<h2 id="24-宽带接入技术">2.4. 宽带接入技术</h2>
<ul>
<li>ADSL技术：改造电话用户线；</li>
<li>光纤同轴混合网（HFC网）：改造有线电视网；</li>
<li>光纤到户（FTTx）：光信号转电信号。</li>
</ul>
<h1 id="3-数据链路层">3. 数据链路层</h1>
<p>数据链路层使用的信道：</p>
<ul>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播信道。这种信道使用一对多的广播通信方式。</li>
</ul>
<h2 id="31-使用点对点信道">3.1. 使用点对点信道</h2>
<h3 id="311-三个基本问题">3.1.1. 三个基本问题</h3>
<p>封装成帧。透明传输、差错检测</p>
<h4 id="3111-封装成帧">3.1.1.1. 封装成帧</h4>
<p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧，</p>
<p>首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。此外，首部和尾部还包括许多必要的控制信息。应当使帧的数据部分长度尽可能地大于首部和尾部的长度。每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送<br>
单元MTU。</p>
<figure data-type="image" tabindex="20"><img src="https://memorykki.github.io/post-images/network-basic/MTU.PNG" alt="" loading="lazy"></figure>
<p>帧定界符SOH和EOT标识真的开始与结束，用以判断一个完整的帧。</p>
<h4 id="3112-透明传输">3.1.1.2. 透明传输</h4>
<p>当传送的用文本组成的帧时，不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p>
<p>但当数据部分是非ASCI码的文本文件时(如二进制代码的计算机程序或图像等)，情<br>
况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样<br>
，数据链路层就会错误地“找到帧的边界”，把部分帧收下(误认为是个完整的<br>
帧)，而把剩下的那部分数据丢弃(这部分找不到帧定界控制字符SOH)。</p>
<figure data-type="image" tabindex="21"><img src="https://memorykki.github.io/post-images/network-basic/EOT.PNG" alt="" loading="lazy"></figure>
<p><strong>字符填充</strong></p>
<p>为了解决透明传输问题，发送端的数据链路层在数据中出现控制字符<br>
SOH”或“EOT”的前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。</p>
<h4 id="3113-差错检测">3.1.1.3. 差错检测</h4>
<p>比特差错：比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。</p>
<p>误码率BER：在一段时间内，传输错误的比特占所传输比特总数的比率。</p>
<p><strong>循环冗余检验CRC</strong></p>
<p><img src="https://memorykki.github.io/post-images/network-basic/CRC1.PNG" alt="" loading="lazy"><br>
<img src="https://memorykki.github.io/post-images/network-basic/CRC2.PNG" alt="" loading="lazy"></p>
<p>判定这个帧有差错，但无法确定究竟是哪一位或哪几位出现了差错。</p>
<p>在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错接受</p>
<p>即:“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。</p>
<p>传输差错：帧丢失、帧重复或帧失序。</p>
<p>过去oSI的观点是:必须让数据链路层向上提供可靠传输。因此在CRC检错的基础上，增加了帧编号、确认和重传机制。</p>
<h3 id="312-点对点协议ppp">3.1.2. 点对点协议PPP</h3>
<p>在TCP/P协议族中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协<br>
议不需要进行纠错，不需要设置序号，也不需要进行流量控制。PPP协议不支持多点线路，只支持点对点的链路通信。此外，PPP协议只支持全双工链路。</p>
<h4 id="3121-协议组成">3.1.2.1. 协议组成</h4>
<p>PPP协议有三个组成部分：</p>
<ol>
<li>将P数据报封装到串行链路的方法。PP既支持异步链路(无奇偶检验的8比<br>
特数据)，也支持面向比特的同步链路。IP数据报在PPP帧中就是其信息部分。这个信息部分的长度受最大传送单元MTU的限制。</li>
<li>用来建立、配置和测试数据链路连接的链路控制协议LCP( Link Cont<br>
Protoco)。通信的双方可协商一些选项。在RFC1661中定义了11种类型的LCP分组</li>
<li>一套网络控制协议 NCP(Network Control Protocol)°，其中的每一个协议支持不同的网络层协议，如IP、OSI的网络层、 DECnet，以及 AppleTalk等</li>
</ol>
<h4 id="3122-ppp帧格式">3.1.2.2. PPP帧格式</h4>
<figure data-type="image" tabindex="22"><img src="https://memorykki.github.io/post-images/network-basic/PPP.PNG" alt="" loading="lazy"></figure>
<ul>
<li>F：0x7E 01111110，标志字段，标识帧的开始或结束</li>
<li>A、C：无意义</li>
<li>协议：表示信息部分使用的协议类型</li>
<li>FCS：检验序列</li>
</ul>
<p><strong>字节填充</strong><br>
使用异步传输时，它把转义符定义为0xD(即ol11101)，并使用字节填充<br>
RFC1662规定了如下所述的填充方法</p>
<ol>
<li>把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D，0x5E)</li>
<li>若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合)，则<br>
把0x7D转变成为2字节序列(0x7D，0x5D)</li>
<li>若信息字段中出现ASCI码的控制字符(即数值小于0x20的字符)，则在该字符前<br>
面要加入一个αx⑦D字节，同时将该字符的编码加以改变。例如，出现0x03(在控制字符中是“传输结束”ETX)就要把它转变为2字节序列(0x7D，Ox23)。</li>
</ol>
<p><strong>零比特填充</strong><br>
使用同步传输时，在发送端，只要发现有5个连续1，则立即填入一个0。因此经过这种填充后的数据，就可以保证在信息字段中不会出现6个连续1。接收端在收到一个帧<br>
时，先找到标志字段F以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续1时，就把这5个连续1后的一个0删除，以还原成原来的信息比特流。</p>
<h4 id="3123-ppp协议工作状态">3.1.2.3. PPP协议工作状态</h4>
<figure data-type="image" tabindex="23"><img src="https://memorykki.github.io/post-images/network-basic/PPPstatus.PNG" alt="" loading="lazy"></figure>
<p>当用户拨号接入ISP后，就建立了一条从用户个人电脑到IsP的物理连接。这时，用户个人电脑向ISSP发送一系列的链路控制协议LCP分组(封装成多个PPP帧)，以便建立LCP连接。这些分组及其响应选择了将要使用的一些PPP参数。接着还要进行网络层配置，网络控制协议NCP给新接入的用户个人电脑分配一个临时的IP地址。这样，用户个人电脑就成为互联网上的一个有IP地址的主机</p>
<p>当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。</p>
<p>在“网络层协议”状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PP协议进行通信<br>
如果在PPP链路上运行的是IP协议，则对PP链路的每一端配置IP协议模块(如分配IP地址)时就要使用NCP中支持IP的协议——IP控制协议IPCP( IP ControlProtoco)IPCP分组也封装成PPP帧(其中的协议字段为0x8021)在PP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和P首部，以减少在链路上发送的比特数。</p>
<p>PPP协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p>
<h2 id="32-使用广播信道">3.2. 使用广播信道</h2>
<h3 id="321-局域网的数据链路层">3.2.1. 局域网的数据链路层</h3>
<p>局域网使用的就是广播信道。按照网络拓扑分为星形网、环形网、总线网。总线网以传统以太网最为著名，之后出现的快速以太网、吉比特以太网在市场中占据绝对优势，以太网成为局域网的同义词。</p>
<p>共享信道技术：</p>
<ul>
<li>静态划分信道：复用分用技术；</li>
<li>动态媒体接入控制：又称多点接入
<ul>
<li>随机接入：用户随机发送信息，需要解决碰撞；</li>
<li>受控接入：用户发送信息需要服从控制。轮询。</li>
</ul>
</li>
</ul>
<h4 id="3211-以太网的两个标准">3.2.1.1. 以太网的两个标准</h4>
<ul>
<li>DIX Ethernet V2</li>
<li>IEEE 802.3</li>
</ul>
<p>二者差别很小。后来IEEE 802将数据链路层拆分为逻辑链路控制LLC( Logical Link Contro)子层和媒体接入控制MAC( Medium Access Control)子层。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关。</p>
<p>后来市场稳定，LLC子层的作用消失，DIX Ethernet V2市场更大。</p>
<h4 id="3212-适配器">3.2.1.2. 适配器</h4>
<p>计算机与外界局域网的连接时通过通信适配器进行的，又称为网络接口卡NIC。装有处理器和存储器（包括RAM和ROM）</p>
<p>作用：</p>
<ul>
<li>串并行的转换</li>
<li>缓存</li>
<li>实现以太网协议</li>
</ul>
<p>工作：</p>
<p>适配器在接收和发送时不使用计算机的CPU。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。</p>
<p>当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p>
<p>计算机的硬件地址就在适配器的ROM中，而计算机的软件地址（IP地址）则在计算机的存储器中。</p>
<h3 id="322-csmacd协议">3.2.2. CSMA/CD协议</h3>
<p>总线使用。</p>
<p>为了通信简便，采用两个措施：</p>
<ol>
<li>采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据<br>
适配器对发送的数据帧不进行编号，也不要求对方发回确认。以太网提供的服务是尽最大努力的交付，即不可靠的交付。</li>
</ol>
<p>当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。对有差错帧是否需要重传则由高层来决定。</p>
<p>总线上在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，因此以太网使用CSMA/CD协议。</p>
<ol start="2">
<li>以太网发送的数据都使用曼彻斯特( Manchester)编码的信号。</li>
</ol>
<p><strong>要点</strong></p>
<ul>
<li>先听后发<br>
在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。</li>
<li>边听边发<br>
在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。</li>
<li>冲突停止<br>
当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。适配器就要立即停止发送，免得继续进行无效的<br>
发送，白白浪费网络资源，然后等待一段随机时间后再次发送。</li>
<li>延迟重发<br>
使用截断二进制指数退避算法确定延迟重发时机。</li>
</ul>
<p>因为传播时延的存在导致先听后发之后人有可能发生碰撞。发送数据后，最迟要经过多长时间才能知道自己发送的数据和其他站发送的数据有没有发生碰撞?这个时间最多是两倍的总线端到端的传播时延(2r)，称为争用期，又叫碰撞窗口。，即经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延(这两个站之间的距离最大)为端到端传播时延。</p>
<figure data-type="image" tabindex="24"><img src="https://memorykki.github.io/post-images/network-basic/crash.PNG" alt="" loading="lazy"></figure>
<p>显然，在使用 CSMA/CD协议时，一个站不可能同时进行发送和接收(但必须边发送<br>
边监听信道)。因此使用 CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信(半双工通信)。</p>
<p>凡长度小于64字节的帧都是由于冲突而中止的无效帧。</p>
<p><strong>强化碰撞</strong><br>
当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送3比特或48比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。</p>
<p><strong>帧间最小间隔</strong><br>
以太网还规定了帧间最小间隔为96μs，相当于96比特时间。这样做是为了使刚刚收<br>
到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p>
<h3 id="323-使用集线器的星形拓扑">3.2.3. 使用集线器的星形拓扑</h3>
<p>集线器和每个站之间使用两对双绞线，用于发送和接收。<br>
IEEE制定了10BASE-T星形以太网标准802.3i。“10”代表10Mbit/s的数据率，BASE表示连接线上的信号是基带信号，T代表双绞线。每个站到集线器的距离不超过100m。</p>
<p><strong>特点</strong></p>
<ul>
<li>用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是<br>
CSMA/CD协议。</li>
<li>一个集线器有许多接口，每个接口通过RJ-45插头用两对双绞线与一台计算机上的适配器相连。因此，一个集线器很像一个多接口的转发器。</li>
<li>集线器工作在物理层，它的每个接口仅仅简单地转发比特，收到1就转发1，收<br>
到0就转发0，不进行碰撞检测。</li>
</ul>
<h3 id="324-信道利用率">3.2.4. 信道利用率</h3>
<pre><code>信道利用率a=\frac{单程端到端时延r}{帧的发送时间T}
</code></pre>
<p>因此，以太网的连线的长度受到限制(否则r数值会太大)，同时以太网的帧长不能太短(否则T的值会太小，使a值太大)。</p>
<h3 id="325-mac层">3.2.5. MAC层</h3>
<h4 id="3251-mac地址">3.2.5.1. MAC地址</h4>
<p>规定了一种48位的全球地址，是指局域网上的每一台计算机中固化在适配器的ROM中的地址。</p>
<p>适配器从网络上每收到一个MAC帧就先用硬件检査MAC帧中的目的地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p>
<p>“发往本站的帧”包括以下三种帧：</p>
<ul>
<li>单播(unicast)帧(一对一)，即收到的帧的MAC地址与本站的硬件地址相同。</li>
<li>广播(broadcast帧(一对全体)，即发送给本局域网上所有站点的帧(全1地址)。</li>
<li>多播(multicas帧(一对多)，即发送给本局域网上一部分站点的帧</li>
</ul>
<p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。显然，只有目的地址才能使用广播地址和多播地址。</p>
<h4 id="3252-mac帧的格式">3.2.5.2. MAC帧的格式</h4>
<ol>
<li>DIX Ethernet V2</li>
</ol>
<figure data-type="image" tabindex="25"><img src="https://memorykki.github.io/post-images/network-basic/MAC.PNG" alt="" loading="lazy"></figure>
<p>类型：标注上一层是什么协议。</p>
<p><strong>帧长度</strong><br>
在曼彻斯特编码的每一个码元(不管码元是1或0)的正中间一定有次电压的转换(从高到低或从低到高)。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了(既不发送1，也不发送0)。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数4字节<br>
(FCS字段长度是4字节)，就能确定数据字段的结束位置。</p>
<p><strong>8字节</strong><br>
第一个字段是7个字节的前同步码(1和0交替码)，它的作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步<br>
也就是“实现位同步”(位同步就是比特同步的意思)。第二个字段是帧开始定界符，定义为10101011。</p>
<p><strong>定界</strong><br>
以太网在传送帧时，各帧之间还必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧。可见以太网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。</p>
<ol start="2">
<li>IEEE802.3</li>
</ol>
<ul>
<li>IEEE8023规定的MAC帧的第三个字段是“长度/类型”。当这个字段值大于<br>
0x0600时(相当于十进制的1536)，就表示“类型”。这样的帧和以太网V2 MAC帧完全<br>
样。只有当这个字段值小于0x0600时才表示“长度”，即MAC帧的数据部分长度。实际上，前面我们已经讲过，由于以太网采用了曼彻斯特编码，长度字段并无实际意义。</li>
<li>当“长度/类型”字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制<br>
JC子层的LLC帧。</li>
</ul>
<h3 id="326-扩展的以太网">3.2.6. 扩展的以太网</h3>
<p>扩展的以太网在网络层看来仍是一个网络。</p>
<h4 id="3261-物理层扩展">3.2.6.1. 物理层扩展</h4>
<p>使用多级结构的集线器。</p>
<figure data-type="image" tabindex="26"><img src="https://memorykki.github.io/post-images/network-basic/physical-ex.PNG" alt="" loading="lazy"></figure>
<p><strong>缺点</strong></p>
<ol>
<li>通过集线器互连起来后就把三个碰撞域变成一个碰撞域，而这时的最大吞吐量没有变化。</li>
<li>如果不同的系使用不同的以太网技术，那么就不可能用集线器将们互连起来。</li>
</ol>
<h4 id="3262-数据链路层扩展">3.2.6.2. 数据链路层扩展</h4>
<p>以太网交换机的出现代替了网桥转发帧。</p>
<h5 id="32621-交换机特点">3.2.6.2.1. 交换机特点</h5>
<ul>
<li>实质是一个多接口的网桥，全双工工作，具有并行性，即同时连通多对接口使之同时通信。主机独占传输媒体，无碰撞地传输数据；</li>
<li>接口有存储器帮助缓存；</li>
<li>即插即用，内部的交换表通过自学习算法自动建立；</li>
<li>用户独享带宽，增加了总吞吐量；</li>
<li>多种速率的接口</li>
</ul>
<h5 id="32622-路由器与交换机的主要区别">3.2.6.2.2. 路由器与交换机的主要区别</h5>
<ol>
<li>工作层次不同 <br>
最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。</li>
<li>数据转发所依据的对象不同 <br>
交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</li>
<li>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域 <br>
由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。</li>
<li>路由器提供了防火墙的服务 <br>
路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</li>
</ol>
<h5 id="32623-以太网的自学习功能">3.2.6.2.3. 以太网的自学习功能</h5>
<figure data-type="image" tabindex="27"><img src="https://memorykki.github.io/post-images/network-basic/self-learn.PNG" alt="" loading="lazy"></figure>
<p>A先向B发送一帧，从接口1进入到交换机。交换机收到帧后，先查找交换表，没有<br>
查到应从哪个接口转发这个帧(在MAC地址这一列中，找不到目的地址为B的项目)。接<br>
着，交换机把这个帧的源地址A和接口1写入交换表中，并向除接口1以外的所有接口<br>
播这个帧(这个帧就是从接口1进来的，当然不应当把它再从接口1转发出去)。<br>
C和D将丢弃这个帧，因为目的地址不对。只B才收下这个目的地址正确的帧。这也<br>
称为过滤。<br>
从新写入交换表的项目(A，1)可以看出，以后不管从哪一个接口收到帧，只要其目的地<br>
址是A，就应当把收到的帧从接口1转发出去。这样做的依据是:既然A发出的帧是从接<br>
口1进入到交换机的，那么从交换机的接口1转发出的帧也应当可以到达A。<br>
假定接下来B通过接口3向A发送一帧。交换机查找交换表，发现交换表中的MAC地址有A。表明要发送给A的帧(即目的地址为A的帧)应从接口1转发。于是就把这个帧传送到接口1转发给A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的项目(B，3)，表明今后如有发送给B的帧，就应当从接口3转发出去。<br>
经过一段时间后，只要主机C和D也向其他主机发送帧，以太网交换机中的交换表就会把转发到C或D应当经过的接口号(2或4)写入到交换表中。这样，交换表中的项目就齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就<br>
自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。<br>
以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置。</p>
<p><strong>生成树协议STP</strong></p>
<figure data-type="image" tabindex="28"><img src="https://memorykki.github.io/post-images/network-basic/STP.PNG" alt="" loading="lazy"></figure>
<p>假定一开始主机A通过接口交换机#1向主机B发送一帧。交换机#1收到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向:离开交换机#1的<br>
接口3→交换机#2的接口1→接口2→交换机#1的接口4→接口3→交换机#的接口这样就无限制地循环兜圈子下去，白白消耗了网络资源<br>
为了解决这种兜圈子问题，IEE的8021D标准制定了一个生成树协议STP( Spanning<br>
Tree Protocol)。其要点就是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p>
<h1 id="4-网络层">4. 网络层</h1>
<h2 id="41-网络层提供的两种服务">4.1. 网络层提供的两种服务</h2>
<ul>
<li>面向连接：虚电路</li>
<li>无连接的</li>
</ul>
<p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服。<br>
网络在发送分组时不需要先建立连接。每一个分组(也就是IP数据报)独立发送，与其前后的分组无关(不进行编号)。网络层不提供服务质量的承诺。</p>
<p>虚电路服务与数据报服务的对比：</p>
<table>
<thead>
<tr>
<th>对比的方面</th>
<th>虚电路服务</th>
<th>数据报服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>思路</td>
<td>靠通信应当由网络来保证</td>
<td>可靠通信应当由用户主机来保证</td>
</tr>
<tr>
<td>连接的建立</td>
<td>必须有</td>
<td>不需要</td>
</tr>
<tr>
<td>终点地址</td>
<td>仅在连接建立阶段使用，每个分组使用短</td>
<td>每个分组都有终点的完整地址</td>
</tr>
<tr>
<td>的虚电路号</td>
<td></td>
<td></td>
</tr>
<tr>
<td>分组的转发</td>
<td>属于同一条虚电路的分组均按照同一路由进行转发</td>
<td>每个分组独立选择路由进行转发</td>
</tr>
<tr>
<td>当结点出故障时</td>
<td>所有通过出故障的结点的虚电路均不能工作</td>
<td>出故障的结点可能会丢失分组</td>
</tr>
<tr>
<td>分组的顺序</td>
<td>总是按发送顺序到达终点</td>
<td>到达终点的时间不一定按发送顺序</td>
</tr>
<tr>
<td>端到端的差错处理和流量控制</td>
<td>可以由网络负责，也可以由用户主机负责</td>
<td>由用户主机负责</td>
</tr>
</tbody>
</table>
<h2 id="42-网际协议ip">4.2. 网际协议IP</h2>
<p>与IP协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议ARP</li>
<li>网际控制报文协议ICMP</li>
<li>网际组管理协议IGMP</li>
<li><s>逆地址解析协议RARP</s>：使只知道自己硬件地址的主机能够通过RARP协议找出其IP地址。现在的DHCP协议已经包含RARP协议的功能。</li>
</ul>
<h3 id="421-分类的ip地址">4.2.1. 分类的IP地址</h3>
<p>IP编址经历的三个历史阶段：</p>
<ol>
<li>分类的IP地址</li>
<li>划分子网</li>
<li>构造超网</li>
</ol>
<h4 id="4211-ip地址的表示">4.2.1.1. IP地址的表示</h4>
<p>一个网络号在整个互联网范围内必须是唯一的，一台主机号在它前面的网络号所指明的网络范围内必须是唯一的，一个IP地址在整个互联网范围内是唯一的。</p>
<p>两级的IP地址可以记为:<br>
IP地址:={&lt;网络号&gt;，&lt;主机号&gt;}</p>
<figure data-type="image" tabindex="29"><img src="https://memorykki.github.io/post-images/network-basic/divideClassIP.PNG" alt="" loading="lazy"></figure>
<h4 id="4212-常见的三类ip地址">4.2.1.2. 常见的三类IP地址</h4>
<p>A类地址的网络号字段占1个字节，只有7位可供使用(该字段的第一位已固定为0)，但可指派的网络号是126个(即27-2)。减2的原因是:第一，IP地址中的全0表示“这个this”。网络号字段为全0的IP地址是个保留地址，意思是“本网络”;第二，网络号为127(即01111111作为本地软件环回测试( loopback test)本主机的进程之间的通信之用。目的地址为环回地址的IP数据报永远不会出现在任何网络上，因为网络号为127的地址根本不是一个网络地址。</p>
<p>A类地址的主机号占3个字节，因此每一个A类网络中的最大主机数是24-2，即6770214。这里减2的原因是:全0的主机号字段表示该IP地址是“本主机”所连接到的单个网络地址(例如，一主机的IP地址为567.8，则该主机所在的网络地址就是567.0.0.0)而全1表示“所有的(a)”，因此全1的主机号字段表示该网络上的所有主机</p>
<p>B类地址的网络号字段有2个字节，但前面两位(10)已经固定了，只剩下14位可以进行分配。因为网络号字段后面的14位无论怎样取值也不可能出现使整个2字节的网络号字段成为全0或全1，因此这里不存在网络总数减2的问题。</p>
<p>C类地址有3个字节的网络号字段，最前面的3位是(110)，还有21位可以进行分配。C类网络地址1920.0.0也是不指派的，可以指派的C类最小网络地址是92010</p>
<p><strong>IP地址的指派范围</strong></p>
<table>
<thead>
<tr>
<th>网络类别</th>
<th>最大可指派的网络数</th>
<th>第一个可指派的网络号</th>
<th>最后一个可指派的网络号</th>
<th>每个网络中的最大主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>2{7}-2</td>
<td>1</td>
<td>126</td>
<td>16777214</td>
</tr>
<tr>
<td>B</td>
<td>2{14}-2</td>
<td>128.1</td>
<td>191.255</td>
<td>65534</td>
</tr>
<tr>
<td>C</td>
<td>2{21}-2</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>254</td>
</tr>
</tbody>
</table>
<p><strong>一般不使用的特殊IP地址</strong></p>
<table>
<thead>
<tr>
<th>网络号</th>
<th>主机号</th>
<th>源地址使用</th>
<th>目的地址使用</th>
<th>代表的意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>可以</td>
<td>不可</td>
<td>在本网络上的本主机(DHCP)</td>
</tr>
<tr>
<td>0</td>
<td>host-id</td>
<td>可以</td>
<td>不可</td>
<td>在本网络上的某台主机 host-id</td>
</tr>
<tr>
<td>全1</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>只在本网络上进行广播(各路由器均不转发)</td>
</tr>
<tr>
<td>net-id</td>
<td>全1</td>
<td>不可</td>
<td>可以</td>
<td>对net-id上的所有主机进行广播</td>
</tr>
<tr>
<td>127</td>
<td>非全0或全1的任何数</td>
<td>可以</td>
<td>可以</td>
<td>用于本地软件环回测试</td>
</tr>
</tbody>
</table>
<p><strong>特点</strong></p>
<ul>
<li>每一个IP地址都由网络号和主机号两部分组成。所以IP地址是一种<br>
分等级的地址结构。分两个等级的好处是:
<ul>
<li>IP地址管理机构在分配I地址时只分配网络号(第一级)，而剩下的主机号(第二级)则由得到该网络号的单位自行分配。</li>
<li>路由器仅根据目的主机所连接的网络号来转发分组(而不考虑目的主机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li>
</ul>
</li>
<li>实际上IP地址是标志一台主机(或路由器)和一条链路的接口。当一台主机同时连<br>
接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的<br>
这种主机称为多归属主机。</li>
<li>用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li>
<li>所有分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网)都是平等的。所谓平等，是指互联网同等对待每一个IP地址。</li>
</ul>
<figure data-type="image" tabindex="30"><img src="https://memorykki.github.io/post-images/network-basic/IPofInternet.PNG" alt="" loading="lazy"></figure>
<h3 id="422-私有地址">4.2.2. 私有地址</h3>
<p>由于IP地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网.实际上，在许多情况下，很多主机主要还是和本机构内的其他主机进行通信。假定在一个机构内部的计算机通信也是采用 TCP/IP协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其IP地址。这就是说，让这些计算机使用仅在本机构有效的酽地址(这种地址称为私有地址)，而不需要向互联网的管理机构申请全球唯一的IP地址(这种地址称为公有地址)。这样就可以大大节约宝贵的全球IP地址资源。</p>
<p>为了解决这一问题，RFC1918指明了一些专用地址( private address)这些地址只能用<br>
于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报<br>
律不进行转发，即</p>
<ul>
<li>10.0.0.0到10.255.255.255(或记为10.0.0.0/8，它又称为24位块)</li>
<li>172.16.0.0到172.16.255.255(或记为172.16.0.0/12，它又称为20位块)</li>
<li>192.168.0.0到192.168.255.255(或记为192.168.0.0/16，它又称为16位块)</li>
</ul>
<p>采用这样的专用IP地址的互连网络就叫做专用网。专用IP地址也叫做可重用地址。</p>
<h3 id="423-网络地址转换nat">4.2.3. 网络地址转换NAT</h3>
<p>下面讨论另一种情况，就是在专用网内部的一些主机本来已经分配到了本地IP地址，即仅在本专用网内使用的专用地址)，但现在又想和互联网上的主机通信(并不需要加密)，那么应当采取什么措施呢?</p>
<p>网络地址转换NAT需要在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。</p>
<h3 id="424-dhcp协议">4.2.4. DHCP协议</h3>
<p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h3 id="425-ip地址与硬件地址">4.2.5. IP地址与硬件地址</h3>
<p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址(用软件实现的)。</p>
<p>IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。当IP数据报放入数据链路层的MAC帧中以后，整个的IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。</p>
<figure data-type="image" tabindex="31"><img src="https://memorykki.github.io/post-images/network-basic/ip-dl.PNG" alt="" loading="lazy"></figure>
<p><strong>要点</strong></p>
<ol>
<li>在IP层抽象的互联网上只能看到IP数据报。</li>
<li>虽然在P数据报首部有源站IP地址，但路由器只根据目的站的I地址的网络号进行路由选择</li>
<li>在局域网的链路层，只能看见MAC帧。<br>
IP数据报被封装在MAC帧中。MAC帧在不同网络上传送时，其MAC帧首部中的源地址和目的地址要发生变化。开始在H1到R1间传送时，MAC帧首部中写的是从硬件地址HA1发送到硬件地址HA3，路由器R1收到此MAC帧后，在数据链路层，要丢弃原来的MAC帧的首部和尾部。在转发时在数据链路层，要重新添加上MAC帧的首部和尾部。这时首部中的源地址和目的地址分别便成为HA4和HA5。路由器R2收到此帧后，再次更换MAC帧的首部和尾部，首部中的源地址和目的地址分别变成为HA6和HA2。MAC帧的首部的这种变化，在上面的IP层上是看不见的。</li>
<li>尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了<br>
下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信。</li>
</ol>
<p>既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的IP地址，而不直接使用硬件地址进行通信?</p>
<p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能<br>
够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项作几乎是不可能的事。但IP编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的IP地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用ARP的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p>
<h3 id="426-地址解析协议arp">4.2.6. 地址解析协议ARP</h3>
<p>网络层使用的是IP地址，但在实际网络的链路上传送数据帧时还是必须使用该网络的硬件地址。但IP地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系。此外，IP或MAC地址可能会改变。地址解析协议ARP解决这个问题的方法是在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新(新增或超时删除)。<br>
每一台主机都设有一个ARP高速缓存( ARP cache)，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p>
<h5 id="4261-同一局域网">4.2.6.1. 同一局域网</h5>
<p>当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中<br>
查看有无主机B的IP地址。</p>
<p>若有，就在ARP高速缓存中查出其对应的硬件地址，再把这硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址；<br>
若没有，主机A就自动运行ARP，然后按以下步骤找出主机B的硬件地址。</p>
<ol>
<li>ARP进程在本局域网上广播发送一个ARP请求分组；</li>
<li>在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</li>
<li>主机B的IP地址与ARP请求分组中要查询的P地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的硬件地址。由于其余的所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此都不理睬这个ARP请求分组。<br>
ARP请求分组是广播发送的，但ARP响应分组是普通的单播。</li>
<li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。同时主机B记录主机A的映射。</li>
</ol>
<p>ARP对保存在高速缓存中的每一个映射地址项目都设置生存时间凡超过生存时间的项目就从高速缓存中删除掉。</p>
<h5 id="4262-不在同一局域网">4.2.6.2. 不在同一局域网</h5>
<p>四种情况：</p>
<figure data-type="image" tabindex="32"><img src="https://memorykki.github.io/post-images/network-basic/ARPfour.PNG" alt="" loading="lazy"></figure>
<ol>
<li>发送方是主机(如H1)，要把IP数据报发送到同一个网络上的另一台主机(如H2)。这时H发送ARP请求分组(在网1上广播)，找到目的主机H2的硬件地址。</li>
<li>发送方是主机(如H1)，要把IP数据报发送到另一个网络上的一台主机(如H3或H4)。这时H1发送ARP请求分组(在网1上广播)，找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。R1要做的事情是下面的(3)或(4)。</li>
<li>发送方是路由器(如R1)，要把P数据报转发到与R1连接在同一个网络(网2)上的主机(如H3)。这时R1发送ARP请求分组(在网2上广播)，找到目的主机H3的硬件地址</li>
<li>发送方是路由器(如R1)，要把IP数据报转发到网3上的一台主机(如H4)。H4与不是连接在同一个网络上。这时R1发送ARP请求分组(在网2上广播)，找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成</li>
</ol>
<h3 id="427-逆地址解析协议rarp">4.2.7. 逆地址解析协议RARP</h3>
<p>功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。</p>
<p><strong>工作流程</strong></p>
<ol>
<li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li>
<li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li>
<li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li>
<li>如果不存在，RARP服务器对此不做任何的响应；</li>
<li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li>
</ol>
<h3 id="428-ip数据报的格式">4.2.8. IP数据报的格式</h3>
<figure data-type="image" tabindex="33"><img src="https://memorykki.github.io/post-images/network-basic/ip.PNG" alt="" loading="lazy"></figure>
<ul>
<li>版本：占4位，指P协议的版本。通信双方使用的P协议的版本必须一致。</li>
<li>首部长度：占4位，可表示的最大十进制数值是15。</li>
</ul>
<p>首部长度字段所表示数的单位是32位字(4字节)，因此首部长度字段的最小值是5，最大值15。当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现IP协议时较为方便。</p>
<ul>
<li>区分服务：占8位，用来获得更好的服务。旧标准中叫做服务类型，但实际上一直没有被使用过。</li>
<li>总长度：总长度指首部和数据之和的长度，单位为字节。</li>
</ul>
<p>最常用的以太网规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行分片处理。</p>
<p>虽然使用尽可能长的PP数据报会使传输效率得到提高，但每一个IP数据报越短，路由<br>
转发的速度就越快。为此，IP协议规定，在互联网中所有的主机和路由器，必须能够接<br>
受长度不超过576字节的数据报。这是假定上层交下来的数据长度有512字节，加上最长的IP首部60字节，再加上4字节的富余量，就得到576字节。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。</p>
<p>在进行分片时(见后面的“片偏移”字段)，数据报首部中的“总长度”字段是指分片<br>
后的每一个分片的首部长度与该分片的数据长度的总和。</p>
<ul>
<li>标识：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</li>
</ul>
<p>但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</p>
<ul>
<li>标志：占3位，但目前只有两位有意义
<ul>
<li>标志字段中的最低位记为MF(More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。</li>
<li>标志字段中间的一位记为DF(Don' t Fragment)，意思是“不能分片”。只有当DF<br>
0时才允许分片。</li>
</ul>
</li>
<li>片偏移：占13位。片偏移指出:较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。这就是说，每个分片的长度一定是8字节(64位)的整数倍。</li>
</ul>
<figure data-type="image" tabindex="34"><img src="https://memorykki.github.io/post-images/network-basic/ip-shard.PNG" alt="" loading="lazy"></figure>
<ul>
<li>生存时间：占8位，生存时间字段常用的英文缩写是TTL( Time To live)，表明<br>
这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子。</li>
</ul>
<p>然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于1秒，后来就把TTL字段的功能改为“跳数限制”(但名称不变)。路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃这个数据报，不再转发。因此，现在TTL的单位不再是秒，而是跳数。TTL的意义是指明数据报在互联网中至多可经过多少路由器。显然，数据报能在互联网中经过的路由器的最大数值是255。若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前TIL值就减小到零，因而就会被这个路由器丢弃。</p>
<ul>
<li>协议：占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的<br>
主机的IP层知道应将数据部分上交给哪个协议进行处理。</li>
<li>首部检验和占16位。这个字段只检验数据报的首部，但不包括数据部分。非CRC。</li>
<li>源地址：占32位。</li>
<li>目的地址：占32位。</li>
</ul>
<h3 id="429-ip层转发分组的流程">4.2.9. IP层转发分组的流程</h3>
<p>在路由表中，对每一条路由最主要的是以下两个信息：</p>
<p><strong>(目的网络地址，下一跳地址)</strong></p>
<ol>
<li>从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N；</li>
<li>若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其<br>
他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧);否则就是间接交付，执行3；</li>
<li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>
下一跳路由器;否则，执行4；</li>
<li>若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由<br>
器;否则，执行5；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>
则，执行6；</li>
<li>报告转发分组出错。</li>
</ol>
<p>当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的IP地址后，不是<br>
把这个地址填入IP数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下跳路由器的IP地址转换成硬件地址(必须使用ARP)，并将此硬件地址放在链路层的<br>
MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用ARP得到硬件地址、把硬件地址写入MAC帧的首部等过程，将不断地重复进行，造成了一定的开销。</p>
<h2 id="43-划分子网和构造超网">4.3. 划分子网和构造超网</h2>
<h3 id="431-划分子网">4.3.1. 划分子网</h3>
<h4 id="4311-三级ip地址">4.3.1.1. 三级IP地址</h4>
<p><strong>两级IP地址的缺点</strong></p>
<ul>
<li>IP地址空间的利用率有时很低。</li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级IP地址不够灵活。</li>
</ul>
<p><strong>基本思路</strong></p>
<ul>
<li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网( subne划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。</li>
<li>划分子网的方法是从网络的主机号借用若干位作为子网号 ibnet-id，当然主机号<br>
也就相应减少了同样的位数。于是两级IP地址在本单位内部就变为三级IP地址:网络号子网号和主机号。也可以用以下记法来表示<br>
<strong>IP地址:={&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}</strong></li>
<li>凡是从其他网络发送给本单位某台主机的IP数据报，路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。</li>
</ul>
<h4 id="4312-子网掩码">4.3.1.2. 子网掩码</h4>
<p>使用子网掩码的好处:不管网络有没有划分子网，只要把子网掩码和IP地址进行<br>
逐位的“与”运算(AND)，就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p>
<figure data-type="image" tabindex="35"><img src="https://memorykki.github.io/post-images/network-basic/subnetMask.PNG" alt="" loading="lazy"></figure>
<p>所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码。默认子网掩码中1的位置和I地址中的网络号字段net-id正好相对应。因此，若用默认子网掩码和某个不划分子网的IP地址逐位相“与”(AND)，就应当能够得出该IP地址的网络地址来。这样做可以不用査找该地址的类别位就能知道这是哪一类的IP地址。显然，</p>
<p>A类地址的默认子网掩码是255.0.0.0，或0xFF000000<br>
B类地址的默认子网掩码是255.255.0.0，或0 XFFFF0000。<br>
C类地址的默认子网掩码是255.255.255.0，或0 XFFFFFF00。</p>
<p>B类地址的子网划分选择(使用固定长度子网)：</p>
<table>
<thead>
<tr>
<th>子网号的位数</th>
<th>子网掩码</th>
<th>子网数</th>
<th>每个子网的主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>255.255.192.0</td>
<td>2{2次方}-2</td>
<td>2{14次方}-2</td>
</tr>
<tr>
<td>2</td>
<td>255.255.224.0</td>
<td>2{3次方}-2</td>
<td>2{13次方}-2</td>
</tr>
<tr>
<td>2</td>
<td>255.255.240.0</td>
<td>2{4次方}-2</td>
<td>2{12次方}-2</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>子网号的位数中没有0，1，15和16这四种情况，因为这没有意义。</p>
<p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p>
<h4 id="4313-使用子网的分组转发">4.3.1.3. 使用子网的分组转发</h4>
<p>我们应当注意到，使用子网划分后，路由表必须包含以下三项内容:</p>
<p><strong>目的网络地址，子网掩码，下一跳地址</strong></p>
<p>在划分子网的情况下，路由器转发分组的算法如下：</p>
<ol>
<li>从收到的数据报的首部提取目的IP地址D；</li>
<li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查:用各网络的子网掩码和D逐位相“与”(AND操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付(当然还需要把D转换成物理地址，把数据报封装成帧发送出去)，转发任务结束。否则就是间接交付，执行3；</li>
<li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的<br>
下一跳路由器;否则，执行4；</li>
<li>对路由表中的每一行(目的网络地址，子网掩码，下一跳地址)，用其中的子网掩<br>
码和D逐位相“与”(AND操作)，其结果为N。若N与该行的目的网络地址匹配，则把数<br>
据报传送给该行指明的下一跳路由器;否则，执行5；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否<br>
则，执行6；</li>
<li>报告转发分组出错。</li>
</ol>
<h3 id="432-构造超网">4.3.2. 构造超网</h3>
<h4 id="4321-网络前缀">4.3.2.1. 网络前缀</h4>
<p>因为IPv4的地址即将耗尽，出现无分类域间路由选择CIDR。</p>
<p><strong>特点</strong></p>
<ul>
<li>CIDR消除了传统的A类、B类和C类地址以及划分子网的概念，32位的IP地址划分为用来指明网络的“网络前缀”和主机号。其记法是：</li>
</ul>
<p><strong>IP地址∷={网络前缀&gt;，&lt;主机号&gt;}</strong></p>
<p>CDR还使用“斜线记法”，或称为CIDR记法，即在IP地址后面加上斜线然后写上网络前缀所占的位数。</p>
<p>CIDR使用32位的地址掩码。地址掩码由串1和一串0组成，而1的个数就是网络前缀的长度。斜线记法中，斜线后面的数字就是地址掩码中1的个数。</p>
<ul>
<li>CIDR把网络前缀都相同的连续的P地址组成一个“CIDR地址块”。</li>
</ul>
<p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的<br>
网络。这种地址的聚合常称为路由聚合( route aggregation)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个(例如上千个)路由。路由聚合也称为构成超网。</p>
<p>常用的CIDR地址块：</p>
<table>
<thead>
<tr>
<th>CIDR前缀长度</th>
<th>点分十进制</th>
<th>包含的地址数</th>
<th>相当于包含分类的网络数</th>
</tr>
</thead>
<tbody>
<tr>
<td>/13</td>
<td>255.248.0.0</td>
<td>512K</td>
<td>8个B类或2048个C类</td>
</tr>
<tr>
<td>/14</td>
<td>255.252.0.0</td>
<td>256K</td>
<td>4个B类或1024个C类</td>
</tr>
<tr>
<td>/15</td>
<td>255.254.0.0</td>
<td>128K</td>
<td>2个B类或512个C类</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>使用CIDR的一个好处就是可以更加有效地分配IPv4的地址空间，可根据客户的需要<br>
分配适当大小的CIDR地址块。然而在分类地址的环境中，向一个部门分配IP地址，就只能以/8，/16或/24为单位来分配，这就很不灵活。</p>
<p>构成超网是将网络前缀缩短。网络前缓越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</p>
<h2 id="44-icmp网际控制报文协议">4.4. ICMP网际控制报文协议</h2>
<p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协<br>
议ICMP。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文是装在IP数据报中，作为其中的数据部分。</p>
<p>两种常用的ICMP报文类型：</p>
<table>
<thead>
<tr>
<th>ICMP报文种类</th>
<th>类型的值</th>
<th>ICMP报文的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>差错报告报文</td>
<td>3</td>
<td>终点不可达：不能交付数据报</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>11</td>
<td>时间超过：生存时间为零的数据报</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>12</td>
<td>参数问题：数据报首部的参数不正确</td>
</tr>
<tr>
<td>差错报告报文</td>
<td>5</td>
<td>改变路由：最佳路由</td>
</tr>
<tr>
<td>询问报文</td>
<td>8或0</td>
<td>回送请求或回答：测试目的站是否可达以及了解其有关状态</td>
</tr>
<tr>
<td>询问报文</td>
<td>13或14</td>
<td>时间戳请求或回答：用于时钟同步和时间测量</td>
</tr>
</tbody>
</table>
<h2 id="45-路由选择协议">4.5. 路由选择协议</h2>
<p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分：</p>
<ul>
<li>静态路由选择策略：也叫做非自适应路由选择，特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。</li>
<li>动态路由选择策略。也叫做自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。适用于较复杂的大网络。</li>
</ul>
<p><strong>分层次的路由选择协议</strong></p>
<p>把整个互联网划分为许多较小的自治系统(autonomous system)，记为AS。一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p>
<p>在目前的互联网中，一个大的ISP就是一个自治系统。这样，互联网就把路由选择协议<br>
划分为两大类：</p>
<ul>
<li>内部网关协议IGP：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。如RIP和OSPF协议。</li>
<li>外部网关协议EGP：若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。目前使用最多的外部网关协议是BGP的版本4(BGP4)。</li>
</ul>
<p>自治系统之间的路由选择也叫做域间路由选择，而在自治系统内部的路由选择叫做域内路由选择。</p>
<h3 id="451-内部网关协议rip">4.5.1. 内部网关协议RIP</h3>
<h4 id="4511-工作原理">4.5.1.1. 工作原理</h4>
<p>一种分布式的基于距离向量的路由选择协议。</p>
<p>RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记<br>
录。RIP协议将“距离”定义为从一路由器到直接连接的网络的距离定义为1。从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1。</p>
<p><strong>特点</strong></p>
<ul>
<li>仅和相邻路由器交换信息。不相邻的路由器不交换信息</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li>
<li>按固定的时间间隔交换路由信息。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li>
</ul>
<h4 id="4512-距离向量算法">4.5.1.2. 距离向量算法</h4>
<p>对每一个相邻路由器发送过来的RIP报文，进行以下步骤：</p>
<ul>
<li>对地址为ⅹ的相邻路由器发来的RIP报文，先修改此报文中的所有项目:把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1。每一个项目都有三个关键数据，即:到目的网络N，距离是d，下一跳路由器是X</li>
<li>对修改后的RP报文中的每一个项目，进行以下步骤:
<ul>
<li>若原来的路由表中没有目的网络N，则把该项目添加到路由表中</li>
<li>否则(即在路由表中有目的网络N，这时就再査看下一跳路由器地址
<ul>
<li>若下一跳路由器地址是Ⅹ，则把收到的项目替换原路由表中的项目</li>
<li>否则(即这个项目是:到目的网络N，但下一跳路由器不是X
<ul>
<li>若收到的项目中的距离d小于路由表中的距离，则进行更新</li>
<li>否则什么也不做。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路<br>
由器，即把距离置为16(距离为16表示不可达)。</li>
<li>返回。</li>
</ul>
<p>RIP协议使得从每一个路由器到每一个目的网络的路由都是最短的。虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p>
<p><strong>优点</strong></p>
<ul>
<li>实现简单、开销较小。</li>
<li>好消息传播得快，但是坏消息传播得慢。</li>
</ul>
<p><strong>缺点</strong>n</p>
<ul>
<li>RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)。</li>
<li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。</li>
</ul>
<h3 id="452-内部网关协议ospf">4.5.2. 内部网关协议OSPF</h3>
<p>开放最短路径优先OSPF，使用最短路径算法SPF，使用分布式的链路状态协议。它是为克服RIP的缺点而开发。</p>
<p><strong>特点</strong></p>
<ul>
<li>向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP协议是仅仅向自己相邻的几个路由器发送信息。</li>
<li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的度量”，称这个度量为“代价”。RIP协议发送的信息是到所有网络的距离和下一跳路由器。</li>
<li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像<br>
RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li>
</ul>
<p><strong>优点</strong></p>
<p>所有的路由器最终都能建立一个链路状态数据库，实际上就是全网的拓扑结构图。这个拓扑结构图在全网范围内是一致的。RIP协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳应当怎样走。</p>
<p>OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表，更新过程收敛得快是其重要优点。</p>
<p>OSPF不用UDP而是直接用IP数据报传送。</p>
<h3 id="453-外部网关协议bgp">4.5.3. 外部网关协议BGP</h3>
<p>内部网关协议(如RIP或OSPF)主要是设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部也不需要考虑其他方面的策略。然而BGP使用的环境却不同。这主要是因为互联网的规模太大，使得自治系统AS之间路由选择非常困难，并且自治系统AS之间的路由选择必须考虑有关策略（自愿连接、安全等）。</p>
<p>所以边界网关协议BGP只能是力求寻找一条能够到达目的网络且比较好的<br>
路由(不能兜圈子)，而并非要寻找一条最佳路由。</p>
<p>BGP采用了路径向量路由选择协议。</p>
<ol>
<li>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”。一般两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器，也可以不是。</li>
<li>BGP发言人与其他AS的BGP发言人要交换路由信息，就要先建立TCP连接，彼此成为对方的邻站( neighbor〕或对等站(peer)。</li>
<li>边界网关协议BGP所交换的网终可达性的信息就是要到达某个网络所要经过的一系列自治系统。发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好路由。</li>
</ol>
<h1 id="5-运输层">5. 运输层</h1>
<h2 id="51-协议概述">5.1. 协议概述</h2>
<h3 id="511-进程之间的通信">5.1.1. 进程之间的通信</h3>
<p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p>
<p>运输层有一个很重要的功能—复用和分用。这里的“复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p>
<p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。向高层用户屏蔽了下面网络核心的细节。</p>
<h3 id="512-两个主要协议">5.1.2. 两个主要协议</h3>
<ul>
<li>用户数据报协议UDP：UDP用户数据报，无连接，不可靠，尽最大努力交付的。</li>
<li>传输控制协议TCP：TCP报文段，面向连接，可靠的</li>
</ul>
<h3 id="513-端口">5.1.3. 端口</h3>
<p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法(而这种方法必须与特定操作系统无关)对TCP体系的应用进程进行标志。</p>
<p>解决这个问题的方法就是在运输层使用协议端口号，常简称为端口(port)。这就是说，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作(即最后交付目的进程)就由TCP或UDP来完成。<br>
这种在协议栈层间的抽象的协议端口是软件端口。</p>
<p>用一个16位端口号来标志一个端口。但端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是没有关联的。16位的端口号可允许有65535个不同的端口。分为：</p>
<ul>
<li>服务器端使用的端口号
<ul>
<li>熟知端口号 0~1023</li>
<li>等级端口号 1024~49151</li>
</ul>
</li>
<li>客户端使用的端口号 49152~65535</li>
</ul>
<p><strong>常见的熟知端口号</strong></p>
<table>
<thead>
<tr>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>SNMP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>161</td>
<td>443</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>POP3</th>
<th>SSH</th>
<th>MySQL</th>
<th>Oracle</th>
<th>SQLServer</th>
<th>Sockets</th>
<th>Tomcat</th>
</tr>
</thead>
<tbody>
<tr>
<td>110</td>
<td>22</td>
<td>3306</td>
<td>1521</td>
<td>1433</td>
<td>1080</td>
<td>8080</td>
</tr>
</tbody>
</table>
<h2 id="52-用户数据报协议udp">5.2. 用户数据报协议UDP</h2>
<ul>
<li>无连接的：减小开销和时延</li>
<li>尽最大努力：交付不可靠的</li>
<li>面向报文：保留上层报文的边界，一次交付一个完整的报文</li>
<li>没有拥塞控制：实时应用允许丢失，但需要低时延</li>
<li>支持一对一、一对多、多对一和多对多的交互通信</li>
<li>首部开销小：8字节</li>
</ul>
<figure data-type="image" tabindex="36"><img src="https://memorykki.github.io/post-images/network-basic/UDP.PNG" alt="" loading="lazy"></figure>
<ul>
<li>源端口：源端口号。在需要对方回信时选用。不需要时可用全0。</li>
<li>目的端口：目的端口号。这在终点交付报文时必须使用</li>
<li>长度：UDP用户数据报的长度，其最小值是8(仅有首部)。</li>
<li>检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃，并由ICMP发送“终点不可达”。IP数据报只检验首部，UDP把首部和数据一起检验。</li>
</ul>
<h2 id="53-传输控制协议tcp概述">5.3. 传输控制协议TCP概述</h2>
<h3 id="531-tcp的主要特点">5.3.1. TCP的主要特点</h3>
<ul>
<li>面向连接：建立连接、释放连接</li>
<li>每条TCP连接只能有两个端点：一对一</li>
<li>可靠交付</li>
<li>全双工通信：发送、接收缓存</li>
<li>面向字节流：然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。</li>
</ul>
<h3 id="532-tcp的连接">5.3.2. TCP的连接</h3>
<p>TCP的连接有两个断电，断电指的是套接字，即端口号拼接到IP地址：</p>
<p><strong>套接字 socket=(IP地址:端口号)</strong></p>
<p>每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定。即</p>
<p><strong>TCP连接:(socket1， socket2)=((IP1:port1)，(IP2:port2)</strong></p>
<h2 id="54-可靠传输的工作原理">5.4. 可靠传输的工作原理</h2>
<h3 id="541-停止等待协议">5.4.1. 停止等待协议</h3>
<p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
<h4 id="5411-无差错情况">5.4.1.1. 无差错情况</h4>
<p>A发送分组M1，发完就暂停发送，等待B的确认。B收到了M1就向A发送确认。A在收到了对M1的确认后，就再发送下一个分组M2。同样，在收到B对M2的确认后，再发送M3。</p>
<figure data-type="image" tabindex="37"><img src="https://memorykki.github.io/post-images/network-basic/TCPstopwait.PNG" alt="" loading="lazy"></figure>
<h4 id="5412-出现差错">5.4.1.2. 出现差错</h4>
<p>B接收M1时检测出了差错，就丢弃M1，其他什么也不做(不通知A收到有差错的分组)。A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，。这就叫做超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</p>
<p>因此要注意：</p>
<ol>
<li>A在发送完一个分组后，必须暂时保留已发送的分组的副本；</li>
<li>分组和确认分组都必须进行编号。</li>
<li>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
</ol>
<h4 id="5413-确认丢失和确认迟到">5.4.1.3. 确认丢失和确认迟到</h4>
<figure data-type="image" tabindex="38"><img src="https://memorykki.github.io/post-images/network-basic/TCPconfirmLossLate.PNG" alt="" loading="lazy"></figure>
<p><strong>确认丢失</strong></p>
<p>B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传M1。现在应注意B的动作。假定B又收到了重传的分组M1。这时应采取两个行动。</p>
<ol>
<li>丢弃这个重复的分组M1，不向上层交付。</li>
<li>向A发送确认。不能认为已经发送过确认就不再发送，因为A之所以重传M</li>
</ol>
<p><strong>确认迟到</strong></p>
<p>传输过程中没有出现差错，但B对分组M1的确认迟到了。A会收到重复的确认。对重复的确认的处理很简单:收下后就丢弃。B仍然会收到重复的M1，并且同样要丢弃重复的M1，并重传确认分组。</p>
<p>像上述的这种可靠传输协议常称为自动重传请求ARQ( Automatic Repeat reQuest)。意思<br>
是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</p>
<h4 id="5414-信道利用率">5.4.1.4. 信道利用率</h4>
<p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p>
<figure data-type="image" tabindex="39"><img src="https://memorykki.github.io/post-images/network-basic/TcpARQ.PNG" alt="" loading="lazy"></figure>
<p>当往返时间RTT远大于分组发送时间TD时，信道的利用率就会非常低。若出现重传，信道的利用率就还要降低。</p>
<p>为了提高传输效率，发送方可以采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。</p>
<p>即使用连续ARQ协议和滑动窗口协议。</p>
<h3 id="542-连续arq协议">5.4.2. 连续ARQ协议</h3>
<p>发送窗口的意义是:位于发送窗口内的5个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p>
<figure data-type="image" tabindex="40"><img src="https://memorykki.github.io/post-images/network-basic/TcpSendWindow.PNG" alt="" loading="lazy"></figure>
<p>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。接收方一般都是采用累积确认的方式。接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示:到这个分组为止的所有分组都已正确收到了。</p>
<p><strong>优缺点</strong></p>
<p>累积确认有优点也有缺点。优点是:容易实现，即使确认丢失也不必重传。但缺点是<br>
不能向发送方反映出接收方已经正确收到的所有分组的信息，在通信质量不好时会多次重传。</p>
<h2 id="55-tcp报文段格式">5.5. TCP报文段格式</h2>
<p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。</p>
<figure data-type="image" tabindex="41"><img src="https://memorykki.github.io/post-images/network-basic/TCP.PNG" alt="" loading="lazy"></figure>
<ul>
<li>源端口和目的端口：各占2个字节，分别写入源端口号和目的端口号。</li>
<li>序号：占4字节。本报文段所发送的数据的第一个字节的序号。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。</li>
<li>确认号：占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明:到序号N-1为止的所有数据都已正确收到。</li>
<li>数据偏移：占4位，实际上是指出TCP报文段的首部长度，单位是32位字(即以4字节）。</li>
<li>保留占6位，保留为今后使用，但目前应置为0。</li>
<li>紧急URG：当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(高优先级的数据)，而不要按原来的排队顺序来传送，例如<kbd>Ctrl + C</kbd>。TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据，这时要与首部中紧急指针字段配合使用。</li>
<li>确认ACK：仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li>
<li>推送PSH：当两个应用进程进行交互式的通信时，一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。发送方TCP把PSH置1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>
<li>复位RST：当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。</li>
<li>同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</li>
<li>终止FIN：用来释放一个连接。</li>
<li>窗口：占2字节。窗口指的是发送本报文段的的接收窗口(而不是自己的发送窗口)。窗口值代表目前允许对方发送的数据量(以字节为单位)。作为接收方让发送方设置其发送窗口的依据。</li>
<li>检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。</li>
<li>紧急指针：占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数，即紧急数据的末尾在报文段中的位置。</li>
<li>选项：长度可变，最长可达40字节。
<ul>
<li>窗口扩大：高吞吐量下增大窗口数值的位数</li>
<li>时间戳：计算RTT；处理序号过大，防止序号取模绕回PAWS</li>
<li>选择确认</li>
</ul>
</li>
</ul>
<p>最大报文段长度MSS：每一个TCP报文段中的数据字段的最大长度。MSS太小，网络利用率降低；太大，IP层需要分片。</p>
<h2 id="56-tcp可靠传输的实现">5.6. TCP可靠传输的实现</h2>
<h3 id="561-以字节为单位的滑动窗口">5.6.1. 以字节为单位的滑动窗口</h3>
<p>发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示己发送且己收到了确认。这些数据显然不需要再保留，而发送窗口前沿的前面部分表示不允许发送的。</p>
<p>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。</p>
<figure data-type="image" tabindex="42"><img src="https://memorykki.github.io/post-images/network-basic/TcpASend11.PNG" alt="" loading="lazy"></figure>
<p>B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31，而不能是32或33。<br>
现在假定B收到了序号为31的数据，并把序号为31-33的数据交付主机，然后B删除这些数据。接着把接收窗口向前移动3个序号，同时给A发送确认，其中窗口值仍为20，但确认号是34。这表明B已经收到了到序号33为止的数据。我们注意到，B还收到了序号为37，38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中A收到B的确认后，就可以把发送窗口向前滑动3个序号，但指针P2不动。可以看出，现在A的可用窗口增大了，可发送的序号范围42-53。</p>
<figure data-type="image" tabindex="43"><img src="https://memorykki.github.io/post-images/network-basic/TcpAReceive.PNG" alt="" loading="lazy"></figure>
<p><strong>TCP的缓存与窗口的关系</strong></p>
<figure data-type="image" tabindex="44"><img src="https://memorykki.github.io/post-images/network-basic/TcpWinCacheRelation.PNG" alt="" loading="lazy"></figure>
<p>发送缓存用来暂时存放:</p>
<ul>
<li>发送应用程序传送给发送方TCP准备发送的数据;</li>
<li>TCP已发送出但尚未收到确认的数据。</li>
</ul>
<p>接收缓存用来暂时存放:</p>
<ul>
<li>按序到达的、但尚未被接收应用程序读取的数据</li>
<li>未按序到达的数据。</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>在同一时刻，A的发送窗口并不总是和B的接收窗口一样大。因为通过网络传送窗口值需要经历一定的时间滞后；</li>
<li>对于不按序到达的数据应如何处理，TCP标准并无明确规定。如果接收方一律丢弃，对网络资源的利用不利，因此通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程；</li>
<li>TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</li>
</ol>
<h3 id="562-超时重传时间的选择">5.6.2. 超时重传时间的选择</h3>
<p>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</p>
<p>TCP采用了一种自适应算法，它记录报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs(这又称为平滑的往返时间）因为进行的是加权平均，因此得出的结果更加平滑)。每当第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值。但以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs：</p>
<p>新的RTTs=(1-α)×(旧的RTTs)+α*(新的RTT样本)</p>
<p>在上式中，0≤α&lt;1。若α很接近于零，表示新的RTTs值和旧的RTTs值相比变化不大，而对新的RTT样本影响不大(RTT值更新较慢)。若选择α接近于1，则表示新的RTTs值受新的RTT样本的影响较大(RT值更新较快)。</p>
<p>显然，超时计时器设置的超时重传时间RTO应略大于RTTs。RFC6298建议使用下式计算RTO</p>
<p>RTO=RTTs+4×RTTD</p>
<p>而RTTD是RTT的偏差的加权平均值，它与RTTs和新的RTT样本之差有关。</p>
<p>RFC6298建议这样计算RTTD。当第一次测量时，RTTD值取为测量到的RTT样本值的一半。在以后的测量中，则使用下式计算加权平均的RTT</p>
<p>新的RTTD=(1-β)×(旧的RTTD+β*|RTTs-新的RTT样本|</p>
<p>若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认则这样计算出的RTTs和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间RTO就越来越长。</p>
<p>Karn提出了一个算法:在计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本，这样得出的加权平均RTTS和RTO就较准确。但是如果报文段的时延突然增大了很多，因<br>
此在原来得出的重传时间内，不会收到确认报文段，于是就重传报文段。但根据Karn算<br>
法，不考虑重传的报文段的往返时间样本，这样，超时重传时间就无法更新。</p>
<p>因此要对Karn算法进行修正。方法是:报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传时，才根据上面给出的2式计算超时重传时间。实践证明，这种策略较为合理。</p>
<h3 id="563-选择确认sack">5.6.3. 选择确认SACK</h3>
<p>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据?选择确认就是一种可行的处理方法。</p>
<figure data-type="image" tabindex="45"><img src="https://memorykki.github.io/post-images/network-basic/SACK.PNG" alt="" loading="lazy"></figure>
<p>和前后字节不连续的每一个字节块都有两个边界:左边界和右边界。因此在图中用四个指针标记这些边界。左边界指出字节块的第一个字节的序号，但右边界减1才是字节块中的最后一个序号。</p>
<p>然而，SACK文档并没有指明发送方应当怎样响应SACK。因此大多数的实现还是重传所有未被确认的数据块。</p>
<h2 id="57-tcp的流量控制">5.7. TCP的流量控制</h2>
<h3 id="571-利用滑动窗口实现流量控制">5.7.1. 利用滑动窗口实现流量控制</h3>
<p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<figure data-type="image" tabindex="46"><img src="https://memorykki.github.io/post-images/network-basic/TcpFlowControl.PNG" alt="" loading="lazy"></figure>
<p>现在我们考虑一种情况。B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd=400的报文段。然而这个报文段在传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p>
<p>为了解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅携带1字节的数据)，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</p>
<h3 id="572-tcp的传输效率">5.7.2. TCP的传输效率</h3>
<p>不同的机制来控制TCP报文段的发送时机</p>
<ol>
<li>TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li>
<li>由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。第三种机制是</li>
<li>发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li>
</ol>
<p>在TCP的实现中广泛使用<strong>Nage算法</strong>。</p>
<p>算法如下:若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。 Nagle算法还规定，当到达的数据已达到发送窗口大小的半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p>
<p><strong>糊涂窗口综合征</strong></p>
<p>设想一种情况:TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节(这样就使接收缓存空间仅腾出1个字节)，然后向发送方发送确认，并把窗口设置为1个字节(但发送的数据报是40字节长)。接着，发送方又发来1个字节的数据(请注意，发送方发送的IP数据报是41字节长)。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。</p>
<p>要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p>
<h2 id="58-tcp的拥塞控制">5.8. TCP的拥塞控制</h2>
<h3 id="581-拥塞控制的一般原理">5.8.1. 拥塞控制的一般原理</h3>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>。若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p>
<p>网络拥塞往往是由许多因素引起的。简单地扩大缓存的存储空间同样会造成网络资源的严重浪费，因而解决不了网络拥塞的问题。简单地将处理机的速率提高，可能会使上述情况缓解一些，但往往又会将瓶颈转移到其他地方。问题的实质往往是整个系统的各个部分不匹配。只有所有的部分都平衡了，问题才会得到解决。</p>
<p>拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程。相反，流量控制往往是指点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<figure data-type="image" tabindex="47"><img src="https://memorykki.github.io/post-images/network-basic/TcpCongestionControl.PNG" alt="" loading="lazy"></figure>
<p>从控制理论的角度来看有两种方法：</p>
<ul>
<li>开环控制：在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</li>
<li>闭环控制是基于反馈环路的概念，主要有以下几种措施
<ul>
<li>监测网络系统以便检测到拥塞在何时、何处发生。</li>
<li>把拥塞发生的信息传送到可采取行动的地方</li>
<li>调整网络系统的运行以解决出现的问题。</li>
</ul>
</li>
</ul>
<p>监测网络的拥塞：</p>
<ul>
<li>指标：由于缺少缓存空间而被丢弃的分组的百分数、平均队列长度、超时重传的分组数、平均分组时延、分组时延的标准差，等等。上述这些指标的上升都标志着拥塞的增长<br>
般在监测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。当然，通知<br>
拥塞发生的分组同样会使网络更加拥塞</li>
<li>比特位：在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥塞是否发生。</li>
</ul>
<h3 id="582-tcp的拥塞控制方法">5.8.2. TCP的拥塞控制方法</h3>
<p>TCP进行拥塞控制的算法有四种：慢开始(sow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)。</p>
<h4 id="5821-慢开始">5.8.2.1. 慢开始</h4>
<p>发送方维持一个叫做<strong>拥塞窗口</strong>cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口。</strong></p>
<p>发送方控制拥塞窗口的原则是:只要网络没有出现拥塞，拥塞窗口就可以再增大些，以便把更多的分组发送出去。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些。</p>
<p>判断网络拥塞的依据就是出现了超时。</p>
<p>慢开始算法的思路是这样的:当主机开始发送数据时，是先探测一下，由小到大逐渐增大发送窗口，即由小到大逐渐增大拥塞窗口数值。</p>
<p>慢开始规定，在每收到一个对新的报文段的确认后，可以把拥塞窗口増加最多一个SMSS的数值。</p>
<p>拥塞窗口cwnd每次的增加量=min(N，SMSS)</p>
<p>请注意，实际上TCP是用<strong>字节数</strong>作为窗口大小的单位。但为叙述方便起见用报文段的个数作为窗口大小的单位。</p>
<figure data-type="image" tabindex="48"><img src="https://memorykki.github.io/post-images/network-basic/TcpSlowStart.PNG" alt="" loading="lazy"></figure>
<p>发送方每收到一个对新报文段的确认就使发送方的拥塞窗口加1每经过一个传输轮次，拥塞窗口cwnd就加倍。</p>
<p>一个传输轮次时间其实就是往返时间RTT(请注意，RTT并非是恒定的数值)。强调把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后个字节的确认。</p>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下:</p>
<p>当cwnd &lt; ssthresh时，使用上述的慢开始算法。<br>
当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>
当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</p>
<h4 id="5822-拥塞避免">5.8.2.2. 拥塞避免</h4>
<p>拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“加法増大”的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>按线性规律增长。但请注意，“拥塞避免”并非完全能够避免了拥塞。“拥塞避免”是说托拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p>
<figure data-type="image" tabindex="49"><img src="https://memorykki.github.io/post-images/network-basic/TcpCwnd.PNG" alt="" loading="lazy"></figure>
<p>当拥塞窗口cwnd=24时，网络出现了超时(图中的点2)，发送方判断为网络拥塞。于是调整门限值 ssthresh=cwnd/2=12，同时设置拥塞窗口cwnd=1，进入慢开始阶段</p>
<p>按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1当拥塞窗口cwnd= ssthresh=12时(图中的点3，这是新的 ssthresh值)，改为执行拥塞避免算法，拥塞窗口按线性规律增大。</p>
<p>当拥塞窗口cwnd=16时(图中的点4)，出现了一个新的情况，就是发送方一连收到3<br>
个对同一个报文段的重复确认(图中记为3-ACK)。</p>
<p>3-ACK解释：</p>
<p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p>
<p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p>
<h4 id="5823-快重传">5.8.2.3. 快重传</h4>
<figure data-type="image" tabindex="50"><img src="https://memorykki.github.io/post-images/network-basic/TcpFastRetransmit.PNG" alt="" loading="lazy"></figure>
<p>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。如图5-26所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4本来接收方可以什么都不做。但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方及早知道接收方没有收到报文段M3。发送方接着发送M5和M6。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M2的确认，其中后3个都是重复确认。</p>
<p>快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应当立即进行重传(即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</p>
<p>因此，在图中的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值 ssthresh=cwnd/2=8，同时设置拥塞窗口cwnd=ssthresh=8(图中的点6)，并开始执行拥塞避免算法。</p>
<h4 id="5824-快恢复">5.8.2.4. 快恢复</h4>
<p>也有的快恢复实现是把快恢复开始时的拥塞窗口cwd值再增大一些(增大报文段的长度)，即等于新的 ssthresh+3×MSS。这样做的理由是:既然发送方收到3个重复的确认，就表明有3个分组已经离开了网络。这3个分组不再消耗网络的资源而是停留在接收方的缓存中(接收方发送出3个重复的确认就证明了这个事实)。可见现在网络中并不是堆积了分组而是减少了3个分组。因此可以适当把拥塞窗口扩大些。</p>
<h4 id="5825-总结">5.8.2.5. 总结</h4>
<figure data-type="image" tabindex="51"><img src="https://memorykki.github.io/post-images/network-basic/TcpCongestionControlProcess.PNG" alt="" loading="lazy"></figure>
<p>在拥塞避免阶段，拥塞窗口是按照线性规律増大的，这常称为加法增大AI，而一旦出现超时或3个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD，二者合在一起就是所谓的AIMD算法。</p>
<p>总之，发送方的窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的：</p>
<p><strong>发送方窗口的上限值 = Min[ rwnd ， cwnd ]</strong></p>
<p>当rwnd &lt; cwnd时，是接收方的接收能力限制发送方窗口的最大值</p>
<p>当cwnd &lt; rwnd时，则是网络的拥塞程度限制发送方窗口的最大值。</p>
<h3 id="583-主动队列管理aqm">5.8.3. 主动队列管理AQM</h3>
<p>网络层路由器的队列通常都是按照“先进先出”FIFO的规则处理到来的分组。当队列已满时，以后再到达的所有分组将都被丢弃。这就叫做<strong>尾部丢弃策略</strong>。这会同时影响到很多条TCP连接，结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP的术语中称为全局同步。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通<br>
信量又突然增大很多。</p>
<p>为了避免发生网络中的全局同步现象，提出了主动队列管理AQM。AQM可以有不同实现方法，其中曾流行多年的就是随机早期检测RED。</p>
<p>实现RED时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED就按照规定的算法先计算当前的平均队列长度：</p>
<ol>
<li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队</li>
<li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li>
<li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率p把新到达的分组丢弃(这就体现了丢弃分组的随机性)</li>
<li></li>
</ol>
<p>由此可见，RED不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，<br>
而是在检测到网络拥塞的早期征兆时(即路由器的平均队列长度达到一定数值时)，就以概<br>
率p丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥<br>
塞控制。</p>
<h2 id="59-tcp的连接管理">5.9. TCP的连接管理</h2>
<h3 id="591-tcp的连接建立">5.9.1. TCP的连接建立</h3>
<figure data-type="image" tabindex="52"><img src="https://memorykki.github.io/post-images/network-basic/3handshake.PNG" alt="" loading="lazy"></figure>
<ol>
<li>
<p>开始，B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于 LISTEN(收听)状态，等待客户的连接请求。如有，即作出响应。</p>
</li>
<li>
<p>A的TCP客户进程也是首先创建传输控制模块TCB。然后，在打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=ⅹ。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但要消耗掉一个序号这时，TCP客户进程进入 SYN-SENT(同步已发送)状态。</p>
</li>
<li>
<p>B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入 SYN-RCVD(同步收到)状态。</p>
</li>
<li>
<p>TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x。</p>
</li>
<li>
<p>这时，TCP连接已经建立，A进入 ESTABLISHED(已建立连接)状态。当B收到A的确认后，也进入 ESTABLISHED状态</p>
</li>
</ol>
<p>为什么A最后还要发送一次确认呢?这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。</p>
<p>所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”。现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用报文握手，那么只要B发出确认，新的连接就建立了由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。</p>
<h3 id="592-tcp的连接释放">5.9.2. TCP的连接释放</h3>
<figure data-type="image" tabindex="53"><img src="https://memorykki.github.io/post-images/network-basic/4handshake.PNG" alt="" loading="lazy"></figure>
<ol>
<li>
<p>数据传输结束后，通信的双方都可释放连接。现在A和B都处于 ESTABLISHED状态。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FN置1，其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FⅠ N-WAIT-1(终止等待1)状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉序号。</p>
</li>
<li>
<p>B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入 CLOSEWAT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于<strong>半关闭</strong>状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。</p>
</li>
<li>
<p>A收到来自B的确认后，就进入 FIN-WAIT2(终止等待2)状态，等待B发出的连接释放报文段。</p>
</li>
<li>
<p>若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w(在半关闭状态B可能又发送了一些数据)。B还必须重复上次已发送过的确认号ack=u+1。这时B就进入 LAST-ACK(最后确认)状态，等待A的确认。</p>
</li>
<li>
<p>A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后进入到 TIME-WAIT(时间等待)状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器( TIME-WAIT timer)设置的时间2MSL后，A才进入到 CLOSED状态。</p>
</li>
</ol>
<p>MSL：最长报文段寿命。</p>
<p>为什么A在 TMME-WAIT状态必须等待2MSL的时间呢?</p>
<ol>
<li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在 LAST-ACK状态的B收不到对已发送的FN+ACK报文段的确认。B会超时重传这个FN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在 TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入 CLOSED状态。1MSL时间留给最后的ACK确认报文段到达服务器端，1MSL时间留给服务器端再次发送的FIN。</li>
<li>防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。B只要收到了A发出的确认，就进入 CLOSED状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早。</li>
</ol>
<p><strong>保活计时器</strong></p>
<p>设想有这样的情况:客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="593-tcp的有限状态机">5.9.3. TCP的有限状态机</h3>
<figure data-type="image" tabindex="54"><img src="https://memorykki.github.io/post-images/network-basic/TcpFiniteState.PNG" alt="" loading="lazy"></figure>
<h1 id="6-应用层">6. 应用层</h1>
<h2 id="61-域名系统dns">6.1. 域名系统DNS</h2>
<p><strong>顶级域名：</strong></p>
<ul>
<li>国家顶级域名：.cn .us</li>
<li>通用顶级域名：.com .org</li>
<li>基础结构域名：.arpa</li>
</ul>
<p><strong>互联网的域名结构：</strong></p>
<figure data-type="image" tabindex="55"><img src="https://memorykki.github.io/post-images/network-basic/domin.PNG" alt="" loading="lazy"></figure>
<p><strong>域名服务器：</strong></p>
<ul>
<li>根域名服务器：最高层次的、最重要的域名服务器</li>
<li>顶级域名服务器：负责管理在该顶级域名服务器下注册的所有二级域名</li>
<li>权限域名服务器：负责一个区的域名服务器</li>
<li>本地域名服务器：默认域名服务器</li>
</ul>
<figure data-type="image" tabindex="56"><img src="https://memorykki.github.io/post-images/network-basic/nameServer.PNG" alt="" loading="lazy"></figure>
<p><strong>解析过程：</strong></p>
<ol>
<li>主机向本地域名服务器的查询一般都是采用递归查询。</li>
</ol>
<p>所谓递归查询就是:如果主机所询问的本地域名服务器不知道被査询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p>
<ol start="2">
<li>本地域名服务器向根域名服务器的查询通常是采用迭代查询</li>
</ol>
<p>迭代査询的特点是这样的:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时要么给出所要查询的IP地址，要么告诉本地域名服务器:“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询(而不是替本地域名服务器进行后续的查询)。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询，本地域名服务器就这样进行迭代査询。最后，知道了所要解析的域名的IP地址，然后把这个结果返回给发起查询的主机。</p>
<figure data-type="image" tabindex="57"><img src="https://memorykki.github.io/post-images/network-basic/nameQuery.PNG" alt="" loading="lazy"></figure>
<p>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNs查询报文数量，在域名服务器中广泛地使用了高速缓存(有时也称为高速缓存域名服务器)。由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项。</p>
<h2 id="62-文件传送协议">6.2. 文件传送协议</h2>
<h3 id="621-ftp">6.2.1. FTP</h3>
<p>文件传送协议FTP是互联网上使用得最广泛的文件送协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p>
<p>基于TCP的FTP和基于UDP的简单文件传送协议TFTP，它们都是文件共享协议中的一大类，即复制整个文件。而网络文件系统NFS则采用另一种思路，允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。在网络上传送的只是少量的修改数据。</p>
<p>FTP的服务器进程由两大部分组成:一个主进程，负责接受新的请求;另外有若干个从属进程，<br>
负责处理单个请求</p>
<p><strong>主进程的工作步骤</strong></p>
<ol>
<li>打开熟知端口(端口号为21)，使客户进程能够连接上</li>
<li>等待客户进程发出连接请求</li>
<li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程发之()回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并行的</li>
</ol>
<p>两个从属进程:控制进程和数据传送进程。为简单起见，服务器端的主进程没有画上</p>
<p>在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接:“控制连<br>
接（21号端口）”和“数据连接（20号端口）”。控制连接在整个会话期间一直保持打开，FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传输文件的是“数据连接”。</p>
<h3 id="622-tftp">6.2.2. TFTP</h3>
<p>简单文件传送协议TFTP，它是个很小且易于实现的文件传送协议。也使用客户服务器方式，但它使用UDP数据报，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p>
<p>每次传送的数据报文中有512字节的数据，但最后一次可不足512字节，这正好可作为文件结束的标志。</p>
<p><strong>优点：</strong></p>
<ol>
<li>TFTP可用于UDP环境</li>
<li>TFTP代码所占的内存较小</li>
</ol>
<h2 id="63-超文本传送协议http">6.3. 超文本传送协议HTTP</h2>
<h3 id="631-http基本过程">6.3.1. HTTP基本过程</h3>
<p>统一资源定位符URL：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/路径&gt;</p>
<p>URL里面的协议和主机不分大小写，路径有时区分。</p>
<p>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。但是HTTP协议本身是无连接的。</p>
<p>HTTP协议是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p>
<p>万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p>
<figure data-type="image" tabindex="58"><img src="https://memorykki.github.io/post-images/network-basic/HTTPtime.PNG" alt="" loading="lazy"></figure>
<p>所以，请求一个万维网文档所需的时间是该文档的传输时间加上两倍往返时间RTT。</p>
<p><strong>HTTP/1.0的主要缺点</strong></p>
<ul>
<li>每请求一个文档就要有两倍RTT的开销。</li>
<li>万维网客户和服务器每一次建立新的TCP连接都要分配缓存和变量。特别是同时服务于大量客户的请求，使用并行TCP连接可以缩短响应时间。</li>
</ul>
<p><strong>HTTP/1.1协议</strong>较好地解决了这个问题，它使用了持续连接( persistent connection)。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p>
<p><strong>持续连接的工作方式：</strong></p>
<ul>
<li>非流水线方式：客户在收到前一个响应后才能发出下一个请求。因此客户每访问一次对象都要用去一个往返时间RTT，比1.0少一个。</li>
<li>流水线方式：客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。因此客户访问所有的对象只需花费一个RTT时间。</li>
</ul>
<p><strong>代理服务器</strong></p>
<p>代理服务器(proxy server)是一种网络实体，它又称为万维网高速缓存( Web cache)。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网<br>
访问该资源。代理服务器可在客户端或服务器端工作，也可在中间系统上工作。</p>
<h3 id="632-http报文">6.3.2. HTTP报文</h3>
<ul>
<li>请求报文</li>
<li>响应报文</li>
</ul>
<figure data-type="image" tabindex="59"><img src="https://memorykki.github.io/post-images/network-basic/HTTPmessage.PNG" alt="" loading="lazy"></figure>
<p>由于HTTP是面向文本的，因此在报文中的每一个字段都是一些ASCI码串，因而各个字段的长度都是不确定的。</p>
<p>HTTP请求报文和响应报文都是由三个部分组成的，区别仅开始行不同。</p>
<h4 id="6321-http请求报文">6.3.2.1. HTTP请求报文</h4>
<p>请求报文的第一行有方法，请求资源的URL，以及HTTP的版本。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get</td>
<td>请求资源</td>
</tr>
<tr>
<td>Post</td>
<td>向服务端发送资源</td>
</tr>
<tr>
<td>Delete</td>
<td>用于删除资源</td>
</tr>
<tr>
<td>Put</td>
<td>用于资源的更新，若资源不存在则新建一个</td>
</tr>
<tr>
<td>Option</td>
<td>请求一些选项信息</td>
</tr>
<tr>
<td>Head</td>
<td>只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载， 以此可以节约带宽资源</td>
</tr>
<tr>
<td>Trace</td>
<td>用于环回测试的请求报文</td>
</tr>
<tr>
<td>Connect</td>
<td>用于代理服务器</td>
</tr>
</tbody>
</table>
<p><strong>Get/Post的区别</strong></p>
<ul>
<li>Get请求的参数放在URL里，有长度限制；Post请求的参数放在实体里，没有限制。</li>
<li>Get请求比起Post请求更加不安全，因为参数放在URL中，不能用来传递敏感信息。</li>
<li>GET用于信息获取，而且应该是安全和幂等的（对同一URL的多个请求应该返回同样的结果）；POST请求表示可能修改服务器上资源的请求</li>
</ul>
<h4 id="6322-http响应报文报文">6.3.2.2. HTTP响应报文报文</h4>
<p>状态行包括三项内容，即HTTP的版本，状态码，以及解释状态码的简单短语</p>
<p>状态码都是三位数字的，分为5大类：</p>
<ul>
<li>1xx：通知信息</li>
<li>2xx：成功</li>
<li>3xx：重定向，中间态，如要完成请求还必须采取进一步的行动</li>
<li>4xx：客户的差错，如请求中有错误的语法或不能完成。</li>
<li>5xx：服务器错误，这些状态代码表示服务器在尝试处理请求时发生内部错误。</li>
</ul>
<p>具体的：</p>
<ul>
<li>
<p>200 OK：表示从客户端发送给服务器的请求被正常处理并返回；</p>
</li>
<li>
<p>204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中没有资源可以返回；</p>
</li>
<li>
<p>206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求。</p>
</li>
<li>
<p>301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</p>
</li>
<li>
<p>302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</p>
</li>
</ul>
<blockquote>
<p>永久是指原来访问的资源已经永久删除啦，客户端应该根据新的URI访问重定向。<br>
临时是指访问的资源可能暂时先用location的URI访问，但旧资源还在的，下次你再来访问的时候可能就不用重定向了。</p>
</blockquote>
<ul>
<li>303 See Other：表示请求的资源被分配了新的URL，客户端应使用GET方法定向获取请求的资源；</li>
<li>304 Not Modified：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源</li>
</ul>
<blockquote>
<p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但是从缓存获取资源客户端在请求一个文件的时候，发现自己有该请求之前的缓存的文件，并且记录了 Last Modified ，那么在请求头中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。在服务端的返回的响应头中通常有Last Modified 如果此值与请求头中的If Modified Since时间一致那么返回就是304，否则就是200。<br>
对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。<br>
因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，并且没有返回页面内容而只是一个 HTTP Header，从而大大的降低带宽的消耗，对于用户的感觉也是提高。</p>
</blockquote>
<ul>
<li>
<p>307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</p>
</li>
<li>
<p>400 Bad Request：表示请求报文中存在语法错误；</p>
</li>
<li>
<p>401 Unauthorized：未经许可，需要通过HTTP认证；</p>
</li>
<li>
<p>403 Forbidden：服务器拒绝该次访问（访问权限出现问题）；</p>
</li>
<li>
<p>404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</p>
</li>
<li>
<p>500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</p>
</li>
<li>
<p>503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</p>
</li>
</ul>
<p><strong>重定向</strong></p>
<p>所谓重定向就是，当浏览器向服务端发送url 请求的时候返回状态码为30x时表示请求被重定向了，例如请求时http://www.a.com 返回的请求头中location:https://www.a.com 那么客户端就要重新根据location 提供的信息重新发起新的请求。例如在外网的ingress  配置http 强制跳转https 的时候就是通过配置301强制跳转的。</p>
<p>请求报文：</p>
<pre><code class="language-http">GET /pet-products.txt HTTP/1.1
Host: www.joes-hardware.com
Accept: *
</code></pre>
<p>服务端响应报文重定向到另一个地址：</p>
<pre><code class="language-http">HTTP/1.1 301 OK
Location: http://www.gentle-grooming.com/
Content-length: 56
Content-type: text/plain
</code></pre>
<p>客户端浏览器收到重定向响应报文后，将发起一个向新地址的请求：</p>
<pre><code class="language-http">GET / HTTP/1.1  
Host: www.gentle-grooming.com
Accept: *
</code></pre>
<p>新地址的响应报文：</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-type: text/html
Content-length: 3307
</code></pre>
<h3 id="633-http协议的区别">6.3.3. HTTP协议的区别</h3>
<p><strong>HTTP1.1比起1.0</strong></p>
<ol>
<li>缓存处理。在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since， If-Match， If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li>带宽优化及网络连接的使用。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>Host头处理，为虚拟化准备。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li>长连接。HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<p><strong>HTTP2.0比起1.1</strong></p>
<ol>
<li>新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li>多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。</li>
<li>header压缩、缓存。如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</li>
</ol>
<figure data-type="image" tabindex="60"><img src="https://memorykki.github.io/post-images/network-basic/HTTPdiff.jpg" alt="" loading="lazy"></figure>
<h3 id="634-https">6.3.4. HTTPS</h3>
<p>HTTPS：是以安全为目标的HTTP通道，简单讲：HTTPS = HTTP + TLS/SSL（TLS的前身是SSL）。</p>
<p>HTTPS协议的主要作用：</p>
<ul>
<li>加密数据，建立一个信息安全通道，来保证数据传输的安全；另一种就是</li>
<li>对网站服务器进行真实身份认证。</li>
</ul>
<h4 id="6341-https的工作原理">6.3.4.1. HTTPS的工作原理</h4>
<figure data-type="image" tabindex="61"><img src="https://memorykki.github.io/post-images/network-basic/HTTPS.png" alt="" loading="lazy"></figure>
<ol>
<li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li>
<li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li>
<li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li>
<li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li>
<li>Server使用对称密钥加密一段内容，发送给Client。</li>
<li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li>
</ol>
<p>Server与Client互相发送加密的握手消息并验证，目的是保证双方获得一致的密码，并且可以正常地加解密，做一次测试。</p>
<p>非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据加密，HASH算法用于验证数据完整性。</p>
<p>SSL握手过程中有任何错误都会是加密连接断开，从而阻止隐私信息的传输，非常安全。攻击者常采用假证书欺骗客户端。</p>
<h4 id="6342-https和http的区别">6.3.4.2. HTTPS和HTTP的区别</h4>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
</ol>
<h3 id="635-http缓存机制">6.3.5. HTTP缓存机制</h3>
<p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：</p>
<ul>
<li>HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)</li>
</ul>
<figure data-type="image" tabindex="62"><img src="https://memorykki.github.io/post-images/network-basic/HttpRequestHead.png" alt="" loading="lazy"></figure>
<ul>
<li>HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体</li>
</ul>
<figure data-type="image" tabindex="63"><img src="https://memorykki.github.io/post-images/network-basic/HttpResponseHead.png" alt="" loading="lazy"></figure>
<p>通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</p>
<p>实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。</p>
<p>浏览器与服务器通信的方式为应答模式，即：浏览器发起HTTP请求 – 服务器响应该请求。</p>
<figure data-type="image" tabindex="64"><img src="https://memorykki.github.io/post-images/network-basic/HttpFirstRequest.png" alt="" loading="lazy"></figure>
<ol>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ol>
<p>根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p>
<h4 id="6351-强制缓存">6.3.5.1. 强制缓存</h4>
<p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：</p>
<ol>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）：</li>
</ol>
<figure data-type="image" tabindex="65"><img src="https://memorykki.github.io/post-images/network-basic/HttpForceCache1.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存：</li>
</ol>
<figure data-type="image" tabindex="66"><img src="https://memorykki.github.io/post-images/network-basic/HttpForceCache2.png" alt="" loading="lazy"></figure>
<p>（3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果：</p>
<figure data-type="image" tabindex="67"><img src="https://memorykki.github.io/post-images/network-basic/HttpForceCache3.png" alt="" loading="lazy"></figure>
<p><strong>强制缓存的缓存规则</strong></p>
<p>当浏览器向服务器发送请求的时候，服务器会将缓存规则（放入HTTP响应的报文的HTTP头中和请求结果一起）返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Conctrol的优先级比Expires高。</p>
<ol>
<li>Expires</li>
</ol>
<p>Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间（绝对时间），即再次发送请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p>
<p>到了HTTP/1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效，那么强制缓存存在的意义就毫无意义。</p>
<ol>
<li>Cache-Control</li>
</ol>
<p>取值为：</p>
<ul>
<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>
<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效（相对时间）</li>
</ul>
<p><strong>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</strong></p>
<p>内存缓存(from memory cache)和硬盘缓存(from disk cache):</p>
<ol>
<li>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</li>
</ol>
<ul>
<li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li>
<li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li>
</ul>
<ol start="2">
<li>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li>
</ol>
<p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>
<p>行为分析：</p>
<p>访问某个网站 –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开网站（渲染） –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache)。ctrl+F5 强制刷新就会200 发起新的请求而忽略缓存。</p>
<h4 id="6352-协商缓存">6.3.5.2. 协商缓存</h4>
<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<ol>
<li>协商缓存生效，返回304：</li>
</ol>
<figure data-type="image" tabindex="68"><img src="https://memorykki.github.io/post-images/network-basic/HttpConsultCacheSucc.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>协商缓存失败，返回200和请求结果：</li>
</ol>
<figure data-type="image" tabindex="69"><img src="https://memorykki.github.io/post-images/network-basic/HttpConsultCacheFail.png" alt="" loading="lazy"></figure>
<p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：</p>
<ul>
<li>Last-Modified / If-Modified-Since</li>
<li>Etag / If-None-Match</li>
</ul>
<p>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p>
<p><strong>Last-Modified / If-Modified-Since</strong></p>
<ol>
<li>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，时间值。</li>
<li>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，告诉服务器上次请求该资源时返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比：</li>
</ol>
<ul>
<li>若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；</li>
<li>否则则返回304，代表资源无更新，可继续使用缓存文件。</li>
</ul>
<p><strong>Etag / If-None-Match</strong></p>
<ol>
<li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</li>
<li>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比：</li>
</ol>
<ul>
<li>一致则返回304，代表资源无更新，继续使用缓存文件；</li>
<li>不一致则重新返回资源文件，状态码为200。</li>
</ul>
<h4 id="6353-总结">6.3.5.3. 总结</h4>
<p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)</p>
<p>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</p>
<figure data-type="image" tabindex="70"><img src="https://memorykki.github.io/post-images/network-basic/HttpCache.png" alt="" loading="lazy"></figure>
<h3 id="636-session和cookie">6.3.6. session和cookie</h3>
<p><strong>session与cookie的区别</strong></p>
<p>session：Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。由于Session存放在服务器端，所以随着时间的推移或者用户访问的增多，会给服务器增加负担。使用的时候要考虑下服务器的性能。</p>
<p>cookie：Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来。由于Cookie是存放在客户端，是可见的，安全性就会很低。因此不建议将一些重要的信息放在cookie中。</p>
<p><strong>区别</strong></p>
<ul>
<li>cookie存放在客户端，session存放在服务器端</li>
<li>cookie不是很安全，别人可以分析你本地的cookie信息进行cookie欺骗，因此重要信息应考虑保存在服务器端</li>
<li>session一定时间内回报存在服务器端，当访问量增大时，会影响服务器性能，从性能方面考虑应使用cookie</li>
<li>不同浏览器对cookie的数据大小限制不同，个数限制也不同</li>
<li>可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中</li>
</ul>
<p><strong>联系</strong></p>
<ul>
<li>都是用来记录用户的信息，以便让服务器分辨不同的用户</li>
<li>可以搭配使用，但都有自己的使用局限，要考虑到安全和性能的问题</li>
</ul>
<p><strong>如果客户端禁止 cookie，session 还能用吗？</strong></p>
<p>如果浏览器禁止cookie，那么客户端访问服务端时无法携带sessionid，服务端无法识别用户身份，便无法进行会话控制，session失效。但可以通过以下几种方法：</p>
<ul>
<li>URL重写：URL重写要求将站点中的所有超链接都进行改造，在超链接后用一个特殊的参数JSESSIONID保存当前浏览器对应session的编号，这样一来，当用户点击超链接访问服务器时，服务器可以从URL后的参数中分析出JSESSIONID，从而找到对应的sesison使用.</li>
<li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用</li>
</ul>
<h2 id="64-输入url之后会发生什么">6.4. 输入URL之后会发生什么</h2>
<h3 id="641-大纲">6.4.1. 大纲</h3>
<ol>
<li>浏览器解析URL</li>
<li>查找资源缓存</li>
<li>DNS解析</li>
<li>建立TCP连接（三次握手）</li>
<li>HTTP/HTTPS发起请求</li>
<li>对TCP报文打包，加入源IP地址和目标IP地址</li>
<li>网络层查询下一跳路由，ARP查询下一跳路由的MAC地址</li>
<li>数据链路层对IP报文打包并附上MAC地址</li>
<li>物理层发送数据</li>
<li>服务器处理请求，响应，浏览器接收HTTP响应</li>
<li>选择关闭TCP连接（四次挥手）</li>
<li>编码、解析构建规则树</li>
<li>渲染树</li>
</ol>
<h3 id="642-具体过程">6.4.2. 具体过程</h3>
<ul>
<li>浏览器解析URL获取协议、域名、端口、路径；</li>
<li>查看浏览器是否有资源的缓存
<ul>
<li>有。判断是否过期
<ul>
<li>没过期。直接读取缓存</li>
<li>过期。
<ul>
<li>Etag和If-None-Match</li>
<li>Last-Modify和lf-Modified-Since</li>
<li>文件修改了则把新资源发给浏览器（状态码200），没修改则告诉浏览器读取缓存（状态码304）</li>
</ul>
</li>
</ul>
</li>
<li>没有则进行下一步</li>
</ul>
</li>
<li>DNS解析
<ul>
<li>寻找浏览器是否存在缓存，若没有</li>
<li>寻找操作系统是否存在缓存，若没有</li>
<li>寻找hosts文件中是否有域名和ip的对应关系，若没有</li>
<li>查找路由器中是否有缓存</li>
<li>寻找DNS服务器是否没缓存，若没有</li>
<li>向本地域名服务器递归查询</li>
<li>本地域名服务器想根域名服务器迭代查询</li>
</ul>
</li>
<li>生成HTTP请求</li>
<li>建立TCP连接，三次握手
<ul>
<li>客户端发送SYN=1，Seq=X</li>
<li>服务端发回SYN=1，ACK=X+1，Seq=Y</li>
<li>客户端发送ACK=Y+1，Seq=Y + 1</li>
</ul>
</li>
<li>如果是HTTP请求，对HTTP报文进行报文分割并标记序号和端口号</li>
<li>如果是HTTPS请求
<ul>
<li>Client发起一个HTTPS的请求，并将自己支持的加密规则发给Server。</li>
<li>Server从中选出一资加密算法和HASH算法，把自己的身份信息以公钥证书形式返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥。</li>
<li>Client使用约定好的HASH算法计算握手消息，并用生成的随机数对消息加密，发给Server。</li>
<li>Server使用自己的私钥解密，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。使用密码解析Client发来的握手消息，并验证HASH是否一致。</li>
<li>Server使用对称密钥加密一段内容，发送给Client。</li>
<li>Client使用对称密钥解密响应的密文，并计算HASH，得到明文内容。</li>
</ul>
</li>
<li>对TCP报文打包，加入源IP地址和目标IP地址。</li>
<li>网络层根据目标IP地址和路由表，查询下一跳路由。使用ARP查询下一跳路由的MAC地址。</li>
<li>数据链路层对IP报文打包并附上MAC地址。</li>
<li>物理层发送数据。</li>
<li>服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。</li>
<li>浏览器接收到HTTP响应，关闭TCP连接或保持复用，四次握手。</li>
<li>如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。</li>
<li>根据响应头的字符集进行解码如果响应头没有字符集，则浏览器会默认用一套解码规则，当解析html解析到meta标签中的编码规则时，则替换成新的解码方式重新解码。</li>
<li>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树。</li>
<li>然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。repaint（重画颜色等，不影响布局）和reflow（组件的几何尺寸变了，重新验证并计算渲染树）。</li>
</ul>
<h1 id="7-参考链接">7. 参考链接</h1>
<ul>
<li>《计算机网络（第7版）》谢希仁，电子工业出版社</li>
<li><a href="https://www.cnblogs.com/maybe2030/p/4781555.html">计算机网络基础知识总结</a></li>
<li><a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">OSI七层模型详解</a></li>
<li><a href="https://www.cnblogs.com/zhengshiqiang47/p/8673559.html">HTTP协议以及HTTP2.0/1.1/1.0区别</a></li>
<li><a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li>
<li><a href="https://blog.csdn.net/banana960531/article/details/85621865">HTTP常见状态码（14种）</a></li>
<li><a href="https://messiahhh.github.io/blog/frontend">菜鸟向前端指南</a></li>
<li><a href="https://www.cnblogs.com/wqhwe/p/5407468.html">HTTP与HTTPS的区别</a></li>
<li><a href="https://www.cnblogs.com/wuwuyong/p/12198928.html">计算机网络常见面试题</a></li>
<li><a href="https://www.cnblogs.com/inception6-lxc/p/9152691.html">计算机网络常见面试题</a></li>
<li><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></li>
<li><a href="https://blog.csdn.net/weixin_41969587/article/details/88836161">HTTP请求和响应3：状态码（status）</a></li>
<li><a href="https://www.cnblogs.com/fanggege/p/13207204.html">http 状态码之3xx</a></li>
<li><a href="https://www.cnblogs.com/chengxs/p/10396066.html">彻底理解浏览器的缓存机制(htp绶存机制)</a></li>
<li><a href="https://mp.weixin.qq.com/s/DId9NRXF0SaMyCo27vmojg">这样看 B 站，可以更快！</a></li>
<li><a href="https://www.cnblogs.com/jxxblogs/p/12088924.html">session与cookie的区别？ 如果客户端禁止 cookie session 还能用吗？</a></li>
</ul>
<br />
                  
              </p>
            </div>
            <div class="post_footer">
              
                <div class="meta">
                  <div class="info">
                    <span class="field tags">
                      <i class="iconfont icon-tag-sm"></i>
                      
                      <a href="https://memorykki.github.io/network/" class="article-info">
                        Network</a>
                      </span>
                  </div>
                </div>
                
              
                <div class="next-post" style="margin-top: 20px;">
                  <div class="next">下一篇</div>
                  <a href="https://memorykki.github.io/webCrawler-basic/">
                    <h3 class="post-title">
                      网络爬虫基础
                    </h3>
                  </a>
                </div>
                
            </div>
          </div>
          
          
          
              <div id="vcomments"></div>
              <script>
                  new Valine({
                      el: '#vcomments',
                      appId: 'krF0ARJcxpFRANhJvt8eQvzB-gzGzoHsz',
                      appKey: 'jNyN9UuoDD1qPl7aXI4bLWYU'
                  })
              </script>
          

        </div>
      </div>
    </div>
  </div>
  <div class="footer">
    <div class="footer_slogan">
        
    </div>

    

    <p>
Powered by<a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
Theme<a href="https://github.com/kytrun/gridea-theme-one" target="_blank">One</a>
<br>
© 2020-2022<a href="https://memorykk.cn" target="_blank">Memorykk</a>
<a href="http://beian.miit.gov.cn" target="_blank">陕ICP备20005895号-1</a>
</p>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <p>
            user: <span id="busuanzi_value_site_uv"></span> site: <span id="busuanzi_value_site_pv"></span> page:
            <span id="busuanzi_value_page_pv"></span>
        </p>
    
</div>



<script src="https://memorykki.github.io/media/scripts/util.js"></script>


  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/default.min.css">
  <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(function() {
        $("#toc").tocify({ selectors: "h2, h3, h4" });
    });
  </script>
</body>

</html>